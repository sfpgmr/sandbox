
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 波形メモリ音源
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


{
  $.OSC_FUNC_INDEX = 0;
  $.OSC_CREATE_FUNC_INDEX = 1;
}

(module
  (type $oscillatorFunc (func (param i32) (result f32)))
;;  (memory $memory (export "memory") 1 10 shared)

  (import "env" "memory" (memory $memory 1 10 shared))
  (export "setRate" (func $set_rate))
  (export "initEnvelope" (func $initEnvelope))
  (export "initEnvelopeWork" (func $initEnvelopeWork))
  (export "keyOnEnvelope" (func $keyOnEnvelope))
  (export "keyOffEnvelope" (func $keyOffEnvelope))
  (export "doEnvelope" (func $doEnvelope))

  
  (export "initMemory" (func $initMemory))
  (export "allocateMemory" (func $allocateMemory))
  (export "freeMemory" (func $freeMemory))

  (export "initWaveTable" (func $initWaveTable))
  (export "allocateWaveTable" (func $allocateWaveTable))
  (export "initWaveTableWork" (func $initWaveTableWork))
  (export "readWaveTable"  (func $readWaveTable))

  (export "initOutputBuffer" (func $initOutputBuffer))

  (table 2 funcref)
  (elem (i32.const {$.OSC_FUNC_INDEX}) $readWaveTable)
  ;;(elem (i32.const {$.OSC_CREATE_FUNC_INDEX}) $createWaveTable)

 

(;;
###############################################################

Envelope Generator
    decay
   /\   sustain
  /  \_________   
 /             |\
/              | \
attack        release
|              |
keyon          keyoff

Envelope .... エンベロープのパラメータ格納用
EnvelopeWork .... エンベロープのインスタンス制御用ワーク

###############################################################
;;)

{@struct Envelope
  ;; bit 31
  ;; 1 ... enable
  ;; 0 ... disable
  i32 flag;
  f32 level;
  f32 attack_time;
  f32 decay_time;
  f32 sustain_level;
  f32 release_time;

  f32 attack_delta;
  f32 decay_delta;
  f32 release_delta;
}

{@struct EnvelopeWork
  i32 env_param_offset;
  i32 flag;
  i32 step;
  f32 counter;
  f32 value;
}

;; -----------------------
;; オシレータ抽象化構造体
;; -----------------------

;; パラメータ
{@struct Oscillator
  ;; フラグ
  ;; bit 0-4 : タイプ
  ;;  0000 ... WaveTable
  ;;  0001 ... WaveSample
  ;; bit 31
  ;;  1 ... enable
  ;;  0 ... disable
  i32 flag;
  ;; 間接呼び出し用インデックス
  i32 call_index;
}

;; ワークエリア
;; ワークエリアは１音につき128バイト割り当てられる
{@struct OscillatorWork
  i32 param_offset;
  f32 pitch;
  f32 sample_rate;
  f32 value;
}


;; --------------------------
;; 波形メモリオシレータ
;; いわゆるwsgとかsccみたいなの
;; --------------------------

;; 波形メモリ・パラメータ
{@struct WaveTable 
  Oscillator base;
  ;; サンプル・サイズは２のべき乗 (min:2)
  ;; 1周期分
  i32 size;
  i32 wave_size_mask;
  ;; Waveデータ開始位置
  f32 wave_data_start;
}

;; 波形メモリ・ワークエリア
{@struct WaveTableWork 
  OscillatorWork base;
  i32 wave_table_offset;
  f32 base_frequency;
  f32 table_sample_rate;
  i32 counter;
  f32 delta;
}

;; --------------------------
;; 波形メモリオシレータ（サンプラタイプ）  
;; まだ手をつけていない
;; --------------------------

{@struct WaveSample

  ;; サンプル・サイズは任意
  i32 size;
  ;; フラグ
  ;; bit 0: 1 ... ループあり 0... ループなし
  i32 flag;
  ;; ループ開始オフセット
  i32 loop_start;
  ;; ループ終了オフセット
  i32 loop_end;
  ;; Waveデータ開始
  f32 wave_data_start;
  ;; サンプルのサンプルレート
  f32 sample_rate;
}

{@struct WaveFormWork
  f32 counter;
  f32 delta;
  f32 value;
}

;; --------------------------
;; フィルター
;; まだ実装できていない
;; --------------------------

{@struct FilterParam
  i32 flag;
  i32 filter_type;
  f32 level;
  f32 freq;
  f32 resonance;
  Envelope envelope;
  f32 counter;
}

{@struct FilterWork
  i32 flag;
}


;; -----------------------
;; 音色
;; -----------------------

;; 音色・パラメータ
{@struct Timbre
  ;; # オシレータ・オフセット
  i32 oscillator_offset;
  ;; ピッチ・エンベロープ
  Envelope pitch_envelope;
  ;; ピッチ・LFO
  i32 pitch_lfo_offset;
  ;; 音量エンベロープ
  Envelope amplitude_envelope;
  ;; 音量LFO・オフセット
  i32 amplitude_lfo_offset;
}

;; 音色ワークエリア
{@struct TimbreWork
  ;; フラグ
  ;; bit 31
  ;;  0 ... enable
  ;;  1 ... disable
  ;; bit 0
  ;;  0 ... keyoff
  ;;  1 ... keyon
  i32 flag;
  i32 timbre_offset;
  f32 pitch;
  ;; オシレータ・ワークエリア（128バイト分）
  i32 oscillator_work_offset[32];
  ;; ピッチ・エンベロープ
  EnvelopeWork pitch_envelope;
  ;; ピッチLFO・ワークエリア(128バイト分)
  i32 pitch_lfo_work_offset[32];

  ;; 音量エンベロープ
  EnvelopeWork amplitude_envelope;
  ;; 音量LFO・ワークエリア
  i32 amplitude_lfo_work_offset[32];
  ;;  FilterWork filter;
  ;; 出力レベル
  f32 output_level;
  f32 value;
}

;; --------------------------------
;; メモリマップ 
;; --------------------------------

{@map
  ;; アロケート済みメモリのオフセット格納用
  i32 alloc_mem_offset;
  ;; オーディオ・インターフェースのサンプルレート
  f32 sample_rate;
  ;; サンプルレートの逆数 1 / sample_rate
  f32 delta;
  ;; オシレータのオフセットアドレスを格納（合計32個）
  i32 oscillator[32];
  ;; 音色 (64個分)
  Timbre timbre[64];
  ;; 音色ワークへのオフセットアドレス
  TimbreWork timbre_work[8];
  ;; outputバッファへのオフセット・アドレス
  i32 output_buffer_offset;
  ;; メモリの先頭位置
  i32 mem_start;
}


;; -----------------------------------
;; 簡易メモリアロケータ 
;; 取ったら取りっぱなしのメモリアロケータ
;; ------------------------------------

  ;; メモリ初期化
  (func $initMemory
    (i32.store
      (&alloc_mem_offset;)
      (&mem_start;)  
    )
  )

  ;; メモリのアロケート
  (func $allocateMemory
    (param $size i32)
    (result i32)
    (local $mem_offset i32)
    (local $mem_page i32)

    ;; 8 byte 境界にそろえる
    (local.set $size
      (i32.and
        (i32.add
          (local.get $size)
          (i32.const 0x7)
        )
        (i32.const 0xffff_fff8)
      )    
    )

    (if
      (i32.gt_u
        (local.tee $mem_page
          (i32.add
            (i32.shr_u
              (local.tee $mem_offset
                (i32.add 
                  (local.get $size) 
                  (i32.load (&alloc_mem_offset;))
                )
              )
              (i32.const 16)
            )
            (i32.const 1)
          )
        )
        (memory.size)
      )

      (then
        ;;メモリが足りない場合、必要な分だけページを拡張する
        (memory.grow
          (i32.const 2)
          ;; (i32.sub
          ;;   (local.get $mem_page)
          ;;   (memory.size)
          ;; )
        )
        (drop)
      )
    )

    (i32.store
      (&alloc_mem_offset;)
      (local.get $mem_offset)
    )
    (local.get $mem_offset)
  )

  ;; 指定オフセットからのメモリを開放する
  (func $freeMemory
    (param $offset i32)
    (i32.store
      (&alloc_mem_offset;)
      (local.get $offset)
    )
  )

;; ----------------------
;; サンプリング周波数の設定
;; ----------------------

  (func $set_rate (param $r f32) 
    (f32.store (&sample_rate;) 
      (local.get $r)
    )
    (f32.store (&delta;)
      (f32.div
        (f32.const 1)
        (local.get $r)
      )
    )
  )


;; -----------------------------------
;;  Wave Table
;; -----------------------------------

  ;; # wave tableの初期化 #
  (func $initWaveTable
    ;; メモリオフセット
    (param $wave_table_offset i32)
    ;; サイズ（２のべき乗単位で指定）
    (param $size i32)

    (i32.store 
      (i32.add
        (&WaveTable.base.flag;)
        (local.get $wave_table_offset)
      )
      (i32.const 0)
    )
    
    (i32.store
      (i32.add
        (&WaveTable.size;)
        (local.get $wave_table_offset)
      )
      (local.get $size)
    )

    (i32.store
      (i32.add
        (&WaveTable.wave_size_mask;)
        (local.get $wave_table_offset)
      )
      (i32.sub
        (local.get $size)
        (i32.const 1)
      )
    )

    ;; 初期化メソッド・音声処理メソッドへのインデックス
    (i32.store
      (i32.add
        (&Oscillator.call_index;)
        (local.get $wave_table_offset)
      )
      (i32.const 0)
    )
  )

  ;; # wave table用メモリのアロケートと初期化 #
  (func $allocateWaveTable
    (param $data_size i32)
    (result i32)
    (local $offset i32)

    (call $initWaveTable
      (local.tee $offset
        (call $allocateMemory
          (i32.add
            (local.get $data_size)
            (#WaveTable - 4;)
          )    
        )
      )
      (local.get $data_size)
    )

    (local.get $offset)
  )

  ;; # wave table workの初期化 #
  (func $initWaveTableWork
    (param $wave_table_work_offset i32)
    (param $wave_table_offset i32)
    (param $base_frequency f32)
    
    (f32.store 
      (i32.add
        (&WaveTableWork.base.sample_rate;)
        (local.get $wave_table_work_offset)
      )
      (f32.load (&sample_rate;))
    )

    (f32.store 
      (i32.add
        (&WaveTableWork.base_frequency;)
        (local.get $wave_table_work_offset)
      )
      (local.get $base_frequency)
    )

    (f32.store 
      (i32.add
        (&WaveTableWork.table_sample_rate;)
        (local.get $wave_table_work_offset)
      )
      (f32.mul
        (local.get $base_frequency)
        (f32.convert_i32_s
          (i32.load
            (i32.add
              (&WaveTable.size;)
              (local.get $wave_table_offset)
            )
          )
        )
      )
    )

    (i32.store
      (i32.add
        (&WaveTableWork.counter;)
        (local.get $wave_table_work_offset)
      )
      (i32.const 0)
    )

    ;;pitch
    (f32.store
      (i32.add
        (&WaveTableWork.base.pitch;)
        (local.get $wave_table_work_offset)
      )
      (f32.const 1)
    )

    ;; delta
    (f32.store
      (i32.add
        (&WaveTableWork.delta;)
        (local.get $wave_table_work_offset)
      )
      (f32.load
        (i32.add
          (&WaveTableWork.base.sample_rate;)
          (local.get $wave_table_work_offset)
        )
      )
    )

    ;; value
    (f32.store
      (i32.add
        (&WaveTableWork.base.value;)
        (local.get $wave_table_work_offset)
      )
      (f32.const 0)
    )

    ;; wave tableへのオフセット
    (i32.store
      (i32.add
        (&WaveTableWork.base.param_offset;)
        (local.get $wave_table_work_offset)
      )
      (local.get $wave_table_offset)
    )


  )

  ;; # wave data の読み出し #
  (func $readWaveTable (type $oscillatorFunc)
    (param $wave_table_work_offset i32)
    (result f32)
    (local $wave_table_offset i32)
    (local $counter i32)
    (local $value f32)
    (local $delta f32)

    (if 
      (f32.le
        (local.tee $delta
          (f32.sub 
            (local.tee $delta
              (f32.load
                (i32.add 
                  (&WaveTableWork.delta;)
                  (local.get $wave_table_work_offset)
                )
              )
            )
            (f32.load
              (i32.add
                (&WaveTableWork.table_sample_rate;)
                (local.get $wave_table_work_offset)
              )
            )
          )
        )
        (f32.const 0)
      )

      (then
        (local.set $wave_table_offset
          (i32.load
            (i32.add 
              (&WaveTableWork.base.param_offset;)
              (local.get $wave_table_work_offset)
            )
          )
        )
        
        ;; delta を進め、波形データを$valueにセットする
        (f32.store 
          (i32.add
            (&WaveTableWork.base.value;)
            (local.get $wave_table_work_offset)
          )
          (local.tee $value
            (f32.load
              (i32.add 
                (i32.shl 
                  (local.tee $counter
                    (i32.and
                      (i32.add
                        (i32.load 
                          (i32.add
                            (&WaveTableWork.counter;)
                            (local.get $wave_table_work_offset)
                          )
                        )
                        (i32.const 1)
                      )
                      (i32.load 
                        (i32.add 
                          (&WaveTable.wave_size_mask;)
                          (local.get $wave_table_offset)
                        )
                      )
                    )
                  )
                  (i32.const 2)
                )
                (i32.add 
                  (&WaveTable.wave_data_start;)
                  (local.get $wave_table_offset)
                )
              )
            )
          )
        )

        (i32.store 
          (i32.add
            (&WaveTableWork.counter;)
            (local.get $wave_table_work_offset)
          )
          (local.get $counter)
        )

        ;; deltaをリセットする

        ;; table_sample_rateの更新
        (f32.store
          (i32.add
            (&WaveTableWork.table_sample_rate;)
            (local.get $wave_table_work_offset)
          )
          (f32.mul
            (f32.load
              (i32.add
                (&WaveTableWork.base_frequency;)
                (local.get $wave_table_work_offset)
              )
            )
            (f32.convert_i32_s
              (i32.load
                (i32.add
                  (&WaveTable.size;)
                  (local.get $wave_table_offset)
                )
              )
            )
          ) 
        )

        (f32.store 
          (i32.add
            (&WaveTableWork.delta;)
            (local.get $wave_table_work_offset)
          )
          (local.tee $delta
            (f32.add 
              (local.get $delta)
              (f32.mul
                (f32.load
                  (i32.add
                    (&WaveTableWork.base.sample_rate;)
                    (local.get $wave_table_work_offset)
                  )
                )
                (f32.load
                  (i32.add
                    (&WaveTableWork.base.pitch;)
                    (local.get $wave_table_work_offset)
                  )
                )
              )
            )
          ) 
        )
        (return (local.get $value))
      )
    )

    (f32.store 
      (i32.add
        (&WaveTableWork.delta;)
        (local.get $wave_table_work_offset)
      )
      (local.get $delta )
    )

    (f32.load
      (i32.add
        (&WaveTableWork.base.value;)
        (local.get $wave_table_work_offset)
      )
    )
  )
  
  ;; -------------------------------------
  ;;  エンベロープジェネレータ 
  ;; -------------------------------------
  
  ;; ## 初期化 ##
  (func $initEnvelope 
    (param $env_param_offset i32)
    (param $flag i32)
    (param $sample_rate f32)
    (param $attack_time f32)
    (param $decay_time f32)
    (param $sustain_level f32)
    (param $release_time f32)

    ;; flag ;;

    (i32.store
      (i32.add
        (&Envelope.flag;)
        (local.get $env_param_offset)
      )
      (local.get $flag)
    )

    ;; attack ;;

    (f32.store
      (i32.add (&Envelope.attack_time;) (local.get $env_param_offset))
      (local.get $attack_time)
    )

    (f32.store 
      (i32.add (&Envelope.attack_delta;) (local.get $env_param_offset))
      (f32.div (f32.const 1)
        (f32.mul 
          (local.get $sample_rate)
          (f32.load (i32.add (&Envelope.attack_time;) (local.get $env_param_offset)))
        )
      )
    )

    ;; decay ;;;;;;;;

    (f32.store
      (i32.add (&Envelope.decay_time;) (local.get $env_param_offset))
      (local.get $decay_time)
    )

    (f32.store 
      (i32.add (&Envelope.decay_delta;) (local.get $env_param_offset))
      (f32.div 
        (f32.sub 
          (f32.const 1) 
          (f32.load (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset)))
        )
        (f32.mul 
          (local.get $sample_rate)
          (f32.load (i32.add (&Envelope.decay_time;) (local.get $env_param_offset)))
        )
      )
    )

    ;; sustain ;;

    (f32.store
      (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset))
      (local.get $sustain_level)
    )

    ;; release ;;

    (f32.store
      (i32.add (&Envelope.release_time;) (local.get $env_param_offset))
      (local.get $release_time)
    )

    (f32.store 
      (i32.add (&Envelope.release_delta;) (local.get $env_param_offset))
      (f32.div (f32.load (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset)))
        (f32.mul 
          (local.get $sample_rate)
          (f32.load (i32.add (&Envelope.release_time;) (local.get $env_param_offset)))
        )
      )
    )
  )

  ;; # エンベロープ・ワークエリアの初期化 #
  (func $initEnvelopeWork 
    (param $env_work_offset i32)
    (param $env_param_offset i32)
    
    ;; envelope parameter offset
    (i32.store
      (i32.add (&EnvelopeWork.env_param_offset;) (local.get $env_work_offset))
      (local.get $env_param_offset)
    )

    ;; counter 
    (f32.store 
      (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
      (f32.const 0)
    )

    ;; step
    (i32.store 
      (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
      (i32.const 0)
    )

    ;; flag 
    (i32.store 
      (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset))
      (i32.const 0)
    )

    ;; value 
    (f32.store 
      (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
      (f32.const 0)
    )

  )

  ;; ## key on 処理 ##
  (func $keyOnEnvelope (param $env_work_offset i32)
    ;; flag ;;
    (i32.store 
      (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset))
      (i32.or (i32.const 0x80000000)
        (i32.load (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset)))
      )
    )
    ;; step ;;
    (i32.store 
      (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
      (i32.const 0)
    )

    ;; counter ;; 
    (f32.store 
      (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
      (f32.const 0)
    )

    ;; value ;; 
    (f32.store 
      (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
      (f32.const 0)
    )

  )

  ;; ## key off 処理 ##
  (func $keyOffEnvelope 
    (param $env_work_offset i32)
    ;; flag ;;
    (i32.store 
      (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset))
      (i32.and 
       (i32.const 0x7fffffff)
       (i32.load (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset)))
      )
    )
    ;; step ;;
    (i32.store 
      (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
      (i32.const 3)
    )
    ;; counter
    (f32.store
      (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
      (f32.const 0)
    )    
  )

  ;; ## エンベロープ処理 ##
  (func $doEnvelope 
    (param $env_work_offset i32)
    (result f32)
    (local $env_param_offset i32) 
    (local $counter f32)
    (local $step i32)
    (local $value f32)

    (local.set $env_param_offset
      (i32.add (&EnvelopeWork.env_param_offset;) (local.get $env_work_offset))
    )

    (local.set $counter 
      (f32.load 
        (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
      )
    )

    (local.set $step
      (i32.load 
        (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
      )
    )

    (if (i32.eq (local.get $step) (i32.const -1))
      (return (f32.const 0))   
    )

    (local.set $value 
      (f32.load 
        (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
      )
    )

    (block $main
      (block $do_release
          (block $do_decay
            (block $do_attack
              (br_table $do_attack $do_decay $main $do_release 
                (local.get $step)
              )
            )

            ;; ### attack ###
            (if (f32.ge            
                  (local.tee $counter
                    (f32.add 
                      (f32.load (&delta;))
                      (local.get $counter)
                    )
                  )
                  (f32.load (i32.add (&Envelope.attack_time;) (local.get $env_param_offset)))
                 )
              (then
                (i32.store
                  (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
                  (i32.const 1)
                )

                (f32.store
                  (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
                  (local.tee $counter
                    (f32.const 0)
                  )
                )
                (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
                  (local.tee $value 
                    (f32.const 1)
                  ) 
                )
              )
              (else
                (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset) )
                  (local.tee $value
                    (f32.add (local.get $value)
                      (f32.load (i32.add(&Envelope.attack_delta;) (local.get $env_param_offset)))
                    )
                  )
                )
              )
            )
            (br $main)
          )
          ;; ### decay ###
          (if (f32.ge            
                (local.tee $counter
                  (f32.add 
                    (f32.load (&delta;))
                    (local.get $counter)
                  )
                )
                (f32.load (i32.add(&Envelope.decay_time;) (local.get $env_param_offset)))
                )
            (then
              (i32.store
                (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
                (i32.const 2)
              )

              (f32.store
                (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
                (local.tee $counter
                  (f32.const 0)
                )
              )
              (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
                (local.tee $value 
                  (f32.load 
                      (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset))
                  )
                ) 
              )
            )
            (else
              (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
                (local.tee $value
                  (f32.sub (local.get $value)
                    (f32.load (i32.add (&Envelope.decay_delta;) (local.get $env_param_offset)))
                  )
                )
              )
            )
          )
          (br $main)
        )
      ;; ### release ###
      (if (f32.ge            
            (local.tee $counter
              (f32.add 
                (f32.load (&delta;))
                (local.get $counter)
              )
            )
            (f32.load (i32.add(&Envelope.release_time;) (local.get $env_param_offset)))
            )
        (then
          (i32.store
            (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
            (i32.const -1)
          )
          (f32.store
            (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
            (local.tee $counter
              (f32.const 0)
            )
          )
          (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
            (local.tee $value (f32.const 0)) 
          )
        )
        (else
          (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
            (local.tee $value
              (f32.sub (local.get $value)
                (f32.load (i32.add (&Envelope.decay_delta;) (local.get $env_param_offset)))
              )
            )
          )
        )
      )
      (br $main)
    )
    
    ;; カウンタを更新
    (f32.store 
      (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
      (local.get $counter)
    )

    ;; level * eg を出力 
    (return 
      (f32.mul 
        (local.get $value)
        (f32.load (i32.add (&Envelope.level;) (local.get $env_param_offset)))
      )
    )
  )

;; --------------------------
;; 音色
;; --------------------------


  (func $keyOnTimbre
    (param $timbre_work_offset i32)
    ;; key on フラグのセット
    (i32.store
      (i32.add
        (&TimbreWork.flag;)
        (local.get $timbre_work_offset)
      )
      (i32.or
        (i32.load
          (i32.add
            (&TimbreWork.flag;)
            (local.get $timbre_work_offset)
          )
        )
        (i32.const 0x1)
      )
    )

    ;; envelopeのキーオン処理
    ;; pitch
    (call $keyOnEnvelope
      (i32.add
        (&TimbreWork.pitch_envelope;)
        (local.get $timbre_work_offset)
      )
    )
    ;; amplitude
    (call $keyOnEnvelope
      (i32.add
        (&TimbreWork.amplitude_envelope;)
        (local.get $timbre_work_offset)
      )
    )
  )

  (func $keyOffTimbre
    (param $timbre_work_offset i32)
    ;; key off  フラグのリセット
    (i32.store
      (i32.add
        (&TimbreWork.flag;)
        (local.get $timbre_work_offset)
      )
      (i32.and
        (i32.load
          (i32.add
            (&TimbreWork.flag;)
            (local.get $timbre_work_offset)
          )
        )
        (i32.const 0xffff_fffe)
      )
    )

    ;; envelopeのキーoff処理
    ;; pitch
    (call $keyOffEnvelope
      (i32.add
        (&TimbreWork.pitch_envelope;)
        (local.get $timbre_work_offset)
      )
    )
    ;; amplitude
    (call $keyOffEnvelope
      (i32.add
        (&TimbreWork.amplitude_envelope;)
        (local.get $timbre_work_offset)
      )
    )

  )

  (func $processTimbre
    (param $timbre_work_offset i32)
    (result f32)
    (local $oscillator_work_offset i32)
    (local $pitch_lfo_work_offset i32)
    (local $amplitude_lfo_work_offset i32)
    (local $pitch f32)
    (local $oscillator_offset i32)

    (local.set $oscillator_offset
      (i32.load
        (i32.add
          (&OscillatorWork.param_offset;)
          (local.get $timbre_work_offset)
        )
      )
    )
    
    ;; Pitchの処理
    ;; pitch = pitch * lfo * envelope
    (f32.store
      (i32.add
        (&OscillatorWork.pitch;)
        (local.tee $oscillator_work_offset
          (i32.load
            (i32.add
              (&TimbreWork.oscillator_work_offset;)
              (local.get $timbre_work_offset)
            )
          )
        )
      )
      (f32.mul
        (f32.mul
          ;; pitch
          (local.tee $pitch
            (f32.load
              (i32.add
                (&TimbreWork.pitch;)
                (local.get $timbre_work_offset)
              )
            )
          )
          ;; lfo処理
          (select 
            (f32.const 1) 
            (call_indirect (type $oscillatorFunc) 
              (local.tee $pitch_lfo_work_offset
                (i32.load
                  (i32.add
                    (&TimbreWork.pitch_lfo_work_offset;)
                    (local.get $timbre_work_offset)
                  )
                )
              )
              (i32.load
                (i32.add
                  (&Oscillator.call_index;)
                  (i32.load
                    (i32.add
                      (&OscillatorWork.param_offset;)
                      (local.get $pitch_lfo_work_offset)
                    )            
                  )
                )
              )
            )
            (i32.eqz 
              (i32.and
                (i32.load
                  (i32.add
                    (&Oscillator.flag;)
                    (i32.load
                      (i32.add
                        (&OscillatorWork.param_offset;)
                        (local.get $pitch_lfo_work_offset)
                      )            
                    )
                  )
                )
                (i32.const 0x8000_0000)
              )
            )        
          )
        )
        ;; envelope
        (select
          (f32.const 1)
          (call $doEnvelope
            (i32.load
              (i32.add
                (&TimbreWork.pitch_envelope;)
                (local.get $timbre_work_offset)
              )
            )
          )
          (i32.eqz
            (i32.and
              (i32.load
                (i32.add
                  (&TimbreWork.pitch_envelope.flag;)
                  (local.get $timbre_work_offset)
                )
              )
              (i32.const 0x8000_0000)
            )
          )
        )
      )
    )

    ;; オシレータ&音量処理
    ;; out = oscillator_output * lfo * envelope * output_level
    (f32.store 
      (i32.add
        (&TimbreWork.value;)
        (local.get $timbre_work_offset)
      )
      (f32.mul 
        (f32.mul
          (f32.mul
            (select 
              (f32.const 1)
              ;; オシレータ
              (call_indirect (type $oscillatorFunc)
                (local.get $oscillator_work_offset)
                (i32.load
                  (i32.add
                    (&Oscillator.call_index;)
                    (local.get $oscillator_offset)
                  )
                )
              )
              (i32.eqz
                (i32.and
                  (i32.load
                    (i32.add
                      (&Oscillator.flag;)
                      (local.get $oscillator_offset)
                    )
                  )
                  (i32.const 0x8000_0000)
                )
              )
            )
            ;; amplitude lfo
            (select
              (f32.const 1)
              (call_indirect (type $oscillatorFunc) 
                (local.tee $amplitude_lfo_work_offset
                  (i32.load
                    (i32.add
                      (&TimbreWork.amplitude_lfo_work_offset;)
                      (local.get $timbre_work_offset)
                    )
                  )
                )
                (i32.load
                  (i32.add
                    (&Oscillator.call_index;)
                    (i32.load
                      (i32.add
                        (&OscillatorWork.param_offset;)
                        (local.get $amplitude_lfo_work_offset)
                      )
                    )
                  )
                )
              )
              (i32.eqz
                (i32.and
                  (i32.load
                    (i32.add
                      (&Oscillator.flag;)
                      (i32.load
                        (i32.add
                          (&OscillatorWork.param_offset;)
                          (local.get $amplitude_lfo_work_offset)
                        )
                      )
                    )
                  )
                  (i32.const 0x8000_0000)
                )
              )          
            )
          )
          ;; amplitude envelope
          (select
            (f32.const 1)
            (call $doEnvelope
              (i32.load
                (i32.add
                  (&TimbreWork.amplitude_envelope;)
                  (local.get $timbre_work_offset)
                )
              )
            )
            (i32.eqz
              (i32.and
                (i32.load
                  (i32.add
                    (&TimbreWork.amplitude_envelope.flag;)
                    (local.get $timbre_work_offset)
                  )
                )
                (i32.const 0x8000_0000)
              )
            )
          )
        )
        ;; output level
        (f32.load
          (i32.add
            (&TimbreWork.output_level;)
            (local.get $timbre_work_offset)
          )
        )
      )
    )
    ;; output 
    (f32.load 
      (i32.add
        (&TimbreWork.value;)
        (local.get $timbre_work_offset)
      )
    )
  )

  ;; 
  ;; output buffer
  ;;


  (func $initOutputBuffer 
    (param $size i32)
    (result i32)
    (local $offset i32)
    (i32.store 
      (&output_buffer_offset;)
      (local.tee $offset
        (call $allocateMemory
          (local.get $size)
        )
      )
    )
    (local.get $offset)
  )

)

