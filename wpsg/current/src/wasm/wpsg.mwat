
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 波形メモリ音源
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


{@
  $.OSC_FUNC_INDEX = 0;
  $.OSC_CREATE_FUNC_INDEX = 1;
  $.FILTER_FUNC_INDEX = 8;
  $.PIx2 = Math.PI * 2;
  $.FIXED_POINT = 16;
  $.FIXED_POINT_SHIFT = 1 << $.FIXED_POINT;
  $.MAX_VOICES = 8;
}

{@macro_def offset(offset_literal,offset_base)}
(i32.add
  (offset_literal)
  (local.get offset_base)
)
{@end_macro_def}

{@macro_def ldo(t,offset_literal,offset_base)}
(t.load
  {@@offset offset_literal,offset_base}
)
{@end_macro_def}

{@macro_def sto(t,offset_literal,offset_base,value)}
(t.store
  {@@offset offset_literal,offset_base}
  value
)
{@end_macro_def}

{@macro_def clamp(s,work,min,max)}
(if (result f32)
  (f32.lt
    (if (result f32)
      (f32.gt 
        (local.tee work
          s
        )
        (f32.const max)
      )
      (then
        (f32.const max)
      )
      (else 
        (local.get work)
      )
    )
    (f32.const min)
  )
  (then
    (f32.const min)
  )
  (else
    (local.get work)
  )
)
{@end_macro_def}


(module
  (type $oscillatorFunc (func (param i32) (result f32)))
  (type $filterFunc (func (param i32)))
;;  (memory $memory (export "memory") 1 10 shared)

  (import "env" "memory" (memory $memory 20 20 shared))

  (import "imports" "sin" (func $sin (param $a f64) (result f64)))
  (import "imports" "cos" (func $cos (param $a f64) (result f64)))
  (import "imports" "sinh" (func $sinh (param $a f64) (result f64)))
  (import "imports" "exp" (func $exp (param $a f64) (result f64)))
  (import "imports" "pow" (func $pow (param $a f64) (param $b f64) (result f64)))

  (export "setRate" (func $set_rate))
  (export "initEnvelope" (func $initEnvelope))
  (export "updateEnvelope" (func $updateEnvelope))
  (export "initEnvelopeWork" (func $initEnvelopeWork))
  (export "keyOnEnvelope" (func $keyOnEnvelope))
  (export "keyOffEnvelope" (func $keyOffEnvelope))
  (export "doEnvelope" (func $doEnvelope))

  
  (export "initMemory" (func $initMemory))
  (export "allocateMemory" (func $allocateMemory))
  (export "freeMemory" (func $freeMemory))

  (export "initWaveTable" (func $initWaveTable))
  (export "allocateWaveTable" (func $allocateWaveTable))
  (export "initWaveTableWork" (func $initWaveTableWork))
  (export "readWaveTable"  (func $readWaveTable))
  (export "setWaveTableSize" (func $setWaveTableSize))

  (export "initFilter" (func $initFilter))
  (export "initFilterWork" (func $initFilterWork))


  (export "initTestTimbre" (func $initTestTimbre))
  (export "processTimbre" (func $processTimbre))
  (export "keyOnTimbre" (func $keyOnTimbre))
  (export "keyOffTimbre" (func $keyOffTimbre))

  (export "initOutputBuffer" (func $initOutputBuffer))
  (export "process" (func $process))
  (export "fill" (func $fill))

  (table 32 funcref)
  (elem (i32.const {$.OSC_FUNC_INDEX}) $readWaveTable)
  ;;(elem (i32.const {$.OSC_CREATE_FUNC_INDEX}) $createWaveTable)
  (elem 
    (i32.const {$.FILTER_FUNC_INDEX}) 
    $lowPassFilter $highPassFilter $bandPassFilter  $notchFilter $lowShelfFilter $HighShelfFilter $PeakingFilter $allPassFilter
  )

 

(;
###############################################################

Envelope Generator
    decay
   /\   sustain
  /  \_________   
 /             |\
/              | \
attack        release
|              |
keyon          keyoff

Envelope .... エンベロープのパラメータ格納用
EnvelopeWork .... エンベロープのインスタンス制御用ワーク

###############################################################
;)

{@struct Envelope
  f32 level;
  f32 attack_time;
  f32 decay_time;
  f32 sustain_level;
  f32 release_time;

  f32 attack_delta;
  f32 decay_delta;
  f32 release_delta;
}

{@struct EnvelopeWork
  i32 env_param_offset;
  i32 flag;
  i32 step;
  f32 counter;
  f32 value;
}

;; -----------------------
;; オシレータ抽象化構造体
;; -----------------------

;; パラメータ
{@struct Oscillator
  ;; フラグ
  ;; bit 0-4 : タイプ
  ;;  0000 ... WaveTable
  ;;  0001 ... WaveSample
  i32 oscillator_type;
  ;; 間接呼び出し用インデックス
  i32 call_index;
}

;; ワークエリア
;; ワークエリアは１音につき128バイト割り当てられる
{@struct OscillatorWork
  i32 param_offset;
  i32 flag;
  f32 pitch;
  f32 level;
  i64 sample_rate;
  f32 value;
}


;; --------------------------
;; 波形メモリオシレータ
;; いわゆるwsgとかsccみたいなの
;; --------------------------

;; 波形メモリ・パラメータ
{@struct WaveTable 
  Oscillator base;
  ;; サンプル・サイズは２のべき乗 (min:2,max:512)
  ;; 1周期分
  i32 size;
  i64 wave_size_mask;
  ;; Waveデータ開始位置
  f32 wave_data_start;
}

;; 波形メモリ・ワークエリア
{@struct WaveTableWork 
  OscillatorWork base;
  i32 wave_table_offset;
  i64 base_frequency;
  i64 table_index;
;;  i64 pitch_work;
  i64 delta;
}

;; --------------------------
;; 波形メモリオシレータ（サンプラタイプ）  
;; まだ手をつけていない
;; --------------------------

{@struct WaveSample

  ;; サンプル・サイズは任意
  i32 size;
  ;; フラグ
  ;; bit 0: 1 ... ループあり 0... ループなし
  i32 flag;
  ;; ループ開始オフセット
  i32 loop_start;
  ;; ループ終了オフセット
  i32 loop_end;
  ;; Waveデータ開始
  f32 wave_data_start;
  ;; サンプルのサンプルレート
  f32 sample_rate;
}

{@struct WaveFormWork
  f32 counter;
  f32 delta;
  f32 value;
}

;; --------------------------
;; フィルター
;; --------------------------

{@struct Filter
  ;; 0 ... low pass
  ;; 1 ... high pass
  ;; 2 ... band pass
  ;; 3 ... notch
  ;; 4 ... low shelf
  ;; 5 ... high shelf
  ;; 6 ... peaking
  ;; 7 ... all pass
  i32 filter_type;
  f32 base_frequency;
  f32 q;
  f32 band_width;
  f32 gain;
}

{@struct FilterWork
  i32 filter;
  f32 a0,a1,a2,b0,b1,b2;
  f32 freq_rate;
  f32 current_frequency;
  f32 in1,in2;
  f32 out1,out2;
  f32 value; 
}

;; -----------------------
;; LFO 
;; -----------------------

{@macro_def adjust_positive(a)}
(f32.mul
  (f32.add
    a
    (f32.const 1)
  )
  (f32.const 0.5)
)
{@end_macro_def}

;; -----------------------
;; 音色
;; -----------------------

;; 音色・パラメータ
{@struct Timbre
  ;; フラグ
  ;; bit 0 ... pitch envelope on/off
  ;; bit 1 ... pitch lfo on/off
  ;; bit 2 ... amplitude envelope on/off
  ;; bit 3 ... amplitude lfo on/off
  ;; bit 4 ... filter on/off
  ;; bit 5 ... filter envelope on/off
  ;; bit 6 ... filter on/off

  i32 flag;

  ;; オシレータ・オフセット
  i32 oscillator_offset;
  ;; オシレータのベース周波数
  f32 oscillator_base_frequency;
  ;; ピッチ・エンベロープ
  Envelope pitch_envelope;
  ;; ピッチ・LFO
  i32 pitch_lfo_offset;
  ;; ピッチ・LFOのベース周波数
  f32 pitch_lfo_base_frequency;
  
  ;; 音量エンベロープ
  Envelope amplitude_envelope;
  ;; 音量LFO・オフセット
  i32 amplitude_lfo_offset;
  ;; 音量LFO・ベース周波数
  f32 amplitude_lfo_base_frequency;
  
  
  ;; フィルタ・パラメータ
  Filter filter;
  ;; フィルタ・エンベロープ
  Envelope filter_envelope;
  ;; フィルタ・LFO・オフセット
  i32 filter_lfo_offset;
  ;; フィルタLFO・ベース周波数
  f32 filter_lfo_base_frequency;
  
}

;; 音色ワークエリア
{@struct TimbreWork
  ;; フラグ
  ;; bit 31
  ;;  1 ... active
  ;;  0 ... deactive
  ;; bit 0
  ;;  0 ... keyoff
  ;;  1 ... keyon
  i32 flag;
  i32 timbre_offset;
  f64 time;
  f32 pitch;
  ;; オシレータ・ワークエリア（128バイト分）
  i32 oscillator_work_offset[32];
  ;; ピッチ・エンベロープ
  EnvelopeWork pitch_envelope;
  ;; ピッチLFO・ワークエリア(128バイト分)
  i32 pitch_lfo_work_offset[32];

  ;; 音量エンベロープ
  EnvelopeWork amplitude_envelope;
  ;; 音量LFO・ワークエリア
  i32 amplitude_lfo_work_offset[32];
  
  ;; フィルタ・ワークエリア
  FilterWork filter;
  ;; フィルタ・エンベロープ・ワークエリア
  EnvelopeWork filter_envelope;
  ;; フィルタLFO・ワークエリア
  i32 filter_lfo_work_offset[32];

  ;; 出力レベル
  f32 output_level;
  f32 value;
}
;; --------------------------------
;; シーケンサ
;; --------------------------------

(;
  仕様＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
  
  # Track データの中身 #

  四分音符 = 120 ステップ
  i32のステップ・コマンドがまずあり、そのあと必要なパラメータが続く。

  # ビット構成 #
  
  bit  0-16 ... ステップ (0-131071)
  bit 17-21 ... コマンド オプション(0-31)
  bit 22-31 ... コマンド (0-511)
    ・ステップは絶対位置

  # コマンド #

  0x000-0x07F ... キーオン・オフ
    bit 17 ... On/Off
    bit 18 ... ボイスアサインあり・なし
      bit 18 がオフの場合、コマンドそのものがキーオンする
      オシレータのインデックスを表す
    bit 19 ... ピッチ データあり
    bit 20 ... ベロシティ データあり
    ・それぞれONでf32のパラメータが続く（可変）
  0x080 ... トラック・ボリューム
    param ... f32 値 (0-1.0)
  0x081 ... マスタ・ボリューム
    param ... f32 値 (0-1.0)
  0x082 ... テンポ
    param ... i32 テンポ (0-255)
  0x083 ... スライド
    bit 17 ... オン・オフ
    bit 18-21 ... スライドの対象 (0-15)
      0 ... ボリューム
      1 ... ピッチ
      2 ... フィルタ・カットオフ
    param ... f32 スピード
  0x084 ... 音色切り替え
    param  .... i32 音色番号
  0x085 ... トラックの有効・無効
    bit 17 ... On/Off
  0x1ff ... トラックの終了
;)

{@struct Track
  f32 pitch;
  f32 level;
  f32 pan;
  i32 track_size;
  i32 track_data;
}

{@struct TrackWork
  i32 track;
  i32 current_timbre_work;
  f32 current_pitch;
  f32 current_level;
  f32 current_pan;
  i32 current_offset;
}

{@struct Sequence
  i32 tempo;
  i32 level;
  i32 step;
  Track track[8];
}

{@struct SequenceWork
  i32 sequence;
  i32 current_tempo;
  i32 current_pitch;
  i32 current_level;
  ;; delta = tempo * step / 60
  i32 delta; 
  ;; 初期値としてサンプルレートを入れる
  i32 step_counter;
  i32 current_step;
  i32 padding;
  ;; TrackWork
  TrackWork track[8];
}

;; --------------------------------
;; メモリマップ 
;; --------------------------------

{@map
  ;; アロケート済みメモリのオフセット格納用
  i32 alloc_mem_offset;
  ;; オーディオ・インターフェースのサンプルレート
  f32 sample_rate;
  ;; サンプルレートの逆数 1 / sample_rate
  f32 delta;
  ;; オシレータのオフセットアドレスを格納（合計32個）
  i32 oscillator[32];
  ;; 音色 (64個分)
  Timbre timbre[64];
  ;; 音色ワークへのオフセットアドレス
  TimbreWork timbre_work[8];
  ;; outputバッファへのオフセット・アドレス
  i32 output_buffer_offset;
  i32 output_buffer_size;
  i32 output_buffer_mask;
  i32 read_offset;
  i32 write_offset;
  ;; テスト用のsin テーブル
  f32 sin_table[32];
  {
    // 正弦波で初期値をセットしておく
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    let data = "";
    for(let i = 0,ei = 32;i < ei;++i){
      view.setFloat32(0,Math.sin(2 * Math.PI * i / 32),true);
      for(let j = 0;j < 4;++j){
        data += '\\' + (view.getUint8(j) | 0).toString(16).padStart(2,'0');
      }
    }
    const offset = $.sin_table[$attributes].offset;
    // dataとして出力
    return `(data (i32.const ${offset}) "${data}")`;
  }  ;; メモリの先頭位置

  ;; シーケンサ
  i32 mem_start;
}


;; -----------------------------------
;; 簡易メモリアロケータ 
;; 取ったら取りっぱなしのメモリアロケータ
;; ------------------------------------

;; メモリ初期化
(func $initMemory
  (i32.store
    (&alloc_mem_offset;)
    (&mem_start;)  
  )
)

  ;; メモリのアロケート
  (func $allocateMemory
  (param $size i32)
  (result i32)
  (local $mem_offset i32)
  (local $mem_offset_before i32)
  (local $mem_page i32)

  ;; 8 byte 境界にそろえる
  (local.set $size
    (i32.and
      (i32.add
        (local.get $size)
        (i32.const 0x7)
      )
      (i32.const 0xffff_fff8)
    )    
  )

  (if
    (i32.gt_u
      (local.tee $mem_page
        (i32.add
          (i32.shr_u
            (local.tee $mem_offset
              (i32.add 
                (local.get $size) 
                (local.tee $mem_offset_before
                  (i32.load (&alloc_mem_offset;))
                )
              )
            )
            (i32.const 16)
          )
          (i32.const 1)
        )
      )
      (memory.size)
    )

    (then
      ;;メモリが足りない場合、必要な分だけページを拡張する
      (memory.grow
        (i32.const 2)
        ;; (i32.sub
        ;;   (local.get $mem_page)
        ;;   (memory.size)
        ;; )
      )
      (drop)
    )
  )

  (i32.store
    (&alloc_mem_offset;)
    (local.get $mem_offset)
  )
  (local.get $mem_offset_before)
)

;; 指定オフセットからのメモリを開放する
(func $freeMemory
  (param $offset i32)
  (i32.store
    (&alloc_mem_offset;)
    (local.get $offset)
  )
)

;; ----------------------
;; サンプリング周波数の設定
;; ----------------------

(func $set_rate (param $r f32) 
  (f32.store (&sample_rate;) 
    (local.get $r)
  )
  (f32.store (&delta;)
    (f32.div
      (f32.const 1)
      (local.get $r)
    )
  )
)


;; -----------------------------------
;;  Wave Table
;; -----------------------------------

;; size update method 
{@macro_def setWaveTableSize_(wave_table,size)}

{@@sto i32,&WaveTable.size;,wave_table,size}

{@@sto i64,&WaveTable.wave_size_mask;,wave_table,
  (i64.sub
    (i64.shl
      (i64.extend_i32_u size)
      (i64.const {$.FIXED_POINT})
    )
    (i64.const 1)
  )
}
{@end_macro_def}

;; # wave tableの初期化 #
(func $initWaveTable
  ;; メモリオフセット
  (param $wave_table_offset i32)
  ;; サイズ（２のべき乗単位で指定）
  (param $size i32)

  (i32.store 
    {@@offset &WaveTable.base.oscillator_type;,$wave_table_offset} 
    (i32.const 0)
  )

  {@@setWaveTableSize_ $wave_table_offset,(local.get $size)}

  ;; 初期化メソッド・音声処理メソッドへのインデックス
  (i32.store
    {@@offset &Oscillator.call_index;,$wave_table_offset}
    (i32.const 0)
  )
)

(func $setWaveTableSize
  (param $wave_table_offset i32)
  (param $size i32)
  {@@setWaveTableSize_ $wave_table_offset,(local.get $size)}
)

;; # wave table用メモリのアロケートと初期化 #
(func $allocateWaveTable
  (param $data_size i32)
  (result i32)
  (local $offset i32)

  (call $initWaveTable
    (local.tee $offset
      (call $allocateMemory
        (i32.add
          (local.get $data_size)
          (#WaveTable - 4;)
        )    
      )
    )
    (local.get $data_size)
  )

  (local.get $offset)
)

{@macro_def mul_fixed(a,b)}
(i64.shr_u 
  (i64.mul a b)
  (i64.const {$.FIXED_POINT})
)
{@end_macro_def}

{@macro_def div_fixed(a,b)}
(i64.div_u
  (i64.shl
    a
    (i64.const {$.FIXED_POINT})
  )
  b
)
{@end_macro_def}

{@macro_def shift_fixed(a)}
(i64.shl 
  a
  (i64.const {$.FIXED_POINT})
)
{@end_macro_def}

{@macro_def calc_delta(base_freq,table_offset,table_work_offset)}
{@@div_fixed
  {@@mul_fixed
    {@@shift_fixed base_freq},
    {@@shift_fixed 
      (i64.extend_i32_u
        {@@ldo i32,&WaveTable.size;,table_offset}
      )
    }
  },
  {@@shift_fixed 
    {@@ldo i64,&WaveTableWork.base.sample_rate;,table_work_offset}
  }
}
{@end_macro_def}

;; # wave table workの初期化 #
(func $initWaveTableWork
  (param $wave_table_work_offset i32)
  (param $wave_table_offset i32)
  (param $base_frequency f32)
  (local $base_frequency_i64 i64)
  

  (local.set $base_frequency_i64
    (i64.trunc_f32_u
      (local.get $base_frequency)
    )
  )

  {@@sto i64,
    &WaveTableWork.base.sample_rate;,$wave_table_work_offset, 
    (i64.trunc_f32_u
      (f32.load (&sample_rate;))
    )
  }

  {@@sto i64,&WaveTableWork.base_frequency;,$wave_table_work_offset, 
    (local.get $base_frequency_i64)
  }

  {@@sto f32,&OscillatorWork.level;,$wave_table_work_offset, 
    (f32.const 1)
  }

  ;;pitch
  {@@sto f32,&WaveTableWork.base.pitch;,$wave_table_work_offset, 
    (f32.const 1)
  }

  ;; {@@sto i64,&WaveTableWork.pitch_work;,$wave_table_work_offset,
  ;;   (i64.const {$.FIXED_POINT_SHIFT})
  ;; }

  {@@sto i64,&WaveTableWork.delta;,$wave_table_work_offset,
    {@@calc_delta (local.get $base_frequency_i64),$wave_table_offset,$wave_table_work_offset}
  }

  {@@sto i64,&WaveTableWork.table_index;,$wave_table_work_offset,
    (i64.const 0)
  }

  ;; value
  {@@sto f32,&WaveTableWork.base.value;,$wave_table_work_offset,
    (f32.const 0)
  }
 
  ;; wave tableへのオフセット
  {@@sto i32,
    &WaveTableWork.base.param_offset;,$wave_table_work_offset,
    (local.get $wave_table_offset)
  }
)

;; # wave data の読み出し #
(func $readWaveTable (type $oscillatorFunc)
  (param $wave_table_work_offset i32)
  (result f32)
  (local $wave_table_offset i32)
  (local $table_index i64)
  (local $delta i64)
  (local $value f32)

  (local.set $wave_table_offset
    {@@ldo i32,&WaveTableWork.base.param_offset;,$wave_table_work_offset} 
  )


  (local.set $table_index
    {@@ldo i64,&WaveTableWork.table_index;,$wave_table_work_offset}    
  )

  (local.set $delta
    {@@mul_fixed  
      {@@ldo i64,&WaveTableWork.delta;,$wave_table_work_offset},
      (i64.trunc_f32_u
        (f32.mul
          {@@ldo f32,&WaveTableWork.base.pitch;,$wave_table_work_offset}
          (f32.const {$.FIXED_POINT_SHIFT})
        )
      )
    }
  )

  {@@sto i64,&WaveTableWork.table_index;,$wave_table_work_offset,
    (local.tee $table_index
      (i64.and
        (i64.add
          (local.get $table_index)
          (local.get $delta)
        )
        {@@ldo i64,&WaveTable.wave_size_mask;,$wave_table_offset}
      )
    )
  }

  (f32.store 
    {@@offset &WaveTableWork.base.value;,$wave_table_work_offset}
    (local.tee $value
      (f32.mul
        (f32.load
          {@@offset &OscillatorWork.level;,$wave_table_work_offset}
        )
        (f32.load
          (i32.add
            (i32.shl
              (i32.wrap_i64
                (i64.shr_u
                  (local.get $table_index)
                  (i64.const {$.FIXED_POINT})
                )
              )
              (i32.const 2)
            )
            (i32.add
              (&WaveTable.wave_data_start;)
              (local.get $wave_table_offset)
            )
          )
        )
      )
    )
  )

  (local.get $value)

)

;; -------------------------------------
;;  エンベロープジェネレータ 
;; -------------------------------------

;; ## 初期化 ##
(func $initEnvelope 
  (param $env_param_offset i32)
  (param $sample_rate f32)
  (param $attack_time f32)
  (param $decay_time f32)
  (param $sustain_level f32)
  (param $release_time f32)
  (param $level f32)
  

  ;; attack ;;

  (f32.store
    (i32.add (&Envelope.attack_time;) (local.get $env_param_offset))
    (local.get $attack_time)
  )

  (f32.store 
    (i32.add (&Envelope.attack_delta;) (local.get $env_param_offset))
    (f32.div (f32.const 1)
      (f32.mul 
        (local.get $sample_rate)
        (f32.load (i32.add (&Envelope.attack_time;) (local.get $env_param_offset)))
      )
    )
  )

  ;; decay ;;;;;;;;

  (f32.store
    (i32.add (&Envelope.decay_time;) (local.get $env_param_offset))
    (local.get $decay_time)
  )

  (f32.store 
    (i32.add (&Envelope.decay_delta;) (local.get $env_param_offset))
    (f32.div 
      (f32.sub 
        (f32.const 1) 
        (f32.load (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset)))
      )
      (f32.mul 
        (local.get $sample_rate)
        (f32.load (i32.add (&Envelope.decay_time;) (local.get $env_param_offset)))
      )
    )
  )

  ;; sustain ;;

  (f32.store
    (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset))
    (local.get $sustain_level)
  )

  ;; release ;;

  (f32.store
    (i32.add (&Envelope.release_time;) (local.get $env_param_offset))
    (local.get $release_time)
  )

  (f32.store 
    (i32.add (&Envelope.release_delta;) (local.get $env_param_offset))
    (f32.div (f32.load (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset)))
      (f32.mul 
        (local.get $sample_rate)
        (f32.load (i32.add (&Envelope.release_time;) (local.get $env_param_offset)))
      )
    )
  )

  (f32.store
    (i32.add (&Envelope.level;) (local.get $env_param_offset))
    (local.get $level)
  )
)

  ;; ## 初期化 ##
(func $updateEnvelope 
  (param $env_param_offset i32)
  (local $sample_rate f32)

  (local.set $sample_rate
    (f32.load (&sample_rate;))
  )
  

  ;; attack ;;

  (f32.store 
    (i32.add (&Envelope.attack_delta;) (local.get $env_param_offset))
    (f32.div (f32.const 1)
      (f32.mul 
        (local.get $sample_rate)
        (f32.load (i32.add (&Envelope.attack_time;) (local.get $env_param_offset)))
      )
    )
  )

  ;; decay ;;;;;;;;

  (f32.store 
    (i32.add (&Envelope.decay_delta;) (local.get $env_param_offset))
    (f32.div 
      (f32.sub 
        (f32.const 1) 
        (f32.load (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset)))
      )
      (f32.mul 
        (local.get $sample_rate)
        (f32.load (i32.add (&Envelope.decay_time;) (local.get $env_param_offset)))
      )
    )
  )

  (f32.store 
    (i32.add (&Envelope.release_delta;) (local.get $env_param_offset))
    (f32.div (f32.load (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset)))
      (f32.mul 
        (local.get $sample_rate)
        (f32.load (i32.add (&Envelope.release_time;) (local.get $env_param_offset)))
      )
    )
  )

)

;; # エンベロープ・ワークエリアの初期化 #
(func $initEnvelopeWork 
  (param $env_work_offset i32)
  (param $env_param_offset i32)
  
  ;; envelope parameter offset
  
  (i32.store
    (i32.add (&EnvelopeWork.env_param_offset;) (local.get $env_work_offset))
    (local.get $env_param_offset)
  )

  ;; counter 
  (f32.store 
    (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
    (f32.const 0)
  )

  ;; step
  (i32.store 
    (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
    (i32.const -1)
  )

  ;; flag 
  (i32.store 
    (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset))
    (i32.const 0)
  )

  ;; value 
  (f32.store 
    (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
    (f32.const 0)
  )

)

;; ## key on 処理 ##
(func $keyOnEnvelope (param $env_work_offset i32)
  ;; flag ;;
  (i32.store 
    (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset))
    (i32.or (i32.const 0x80000000)
      (i32.load (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset)))
    )
  )
  ;; step ;;
  (i32.store 
    (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
    (i32.const 0)
  )

  ;; counter ;; 
  (f32.store 
    (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
    (f32.const 0)
  )

  ;; value ;; 
  (f32.store 
    (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
    (f32.const 0)
  )

)

;; ## key off 処理 ##
(func $keyOffEnvelope 
  (param $env_work_offset i32)
  ;; flag ;;
  (i32.store 
    (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset))
    (i32.and 
      (i32.const 0x7fffffff)
      (i32.load (i32.add (&EnvelopeWork.flag;) (local.get $env_work_offset)))
    )
  )
  ;; step ;;
  (i32.store 
    (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
    (i32.const 3)
  )
  ;; counter
  (f32.store
    (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
    (f32.const 0)
  )    
)

;; ## エンベロープ処理 ##
(func $doEnvelope 
  (param $env_work_offset i32)
  (result f32)
  (local $env_param_offset i32) 
  (local $counter f32)
  (local $step i32)
  (local $value f32)

  (local.set $env_param_offset
    (i32.load (i32.add (&EnvelopeWork.env_param_offset;) (local.get $env_work_offset)))
  )

  (local.set $counter 
    (f32.load 
      (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
    )
  )

  (local.set $step
    (i32.load 
      (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
    )
  )

  (if (i32.eq (local.get $step) (i32.const -1))
    (return (f32.const 0))   
  )

  (local.set $value 
    (f32.load 
      (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
    )
  )

  (block $main
    (block $do_release
        (block $do_decay
          (block $do_attack
            (br_table $do_attack $do_decay $main $do_release 
              (local.get $step)
            )
          )

          ;; ### attack ###
          (if (f32.ge            
                (local.tee $counter
                  (f32.add 
                    (f32.load (&delta;))
                    (local.get $counter)
                  )
                )
                (f32.load (i32.add (&Envelope.attack_time;) (local.get $env_param_offset)))
                )
            (then
              (i32.store
                (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
                (i32.const 1)
              )

              (f32.store
                (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
                (local.tee $counter
                  (f32.const 0)
                )
              )
              (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
                (local.tee $value 
                  (f32.const 1)
                ) 
              )
            )
            (else
              (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset) )
                (local.tee $value
                  (f32.add (local.get $value)
                    (f32.load (i32.add(&Envelope.attack_delta;) (local.get $env_param_offset)))
                  )
                )
              )
            )
          )
          (br $main)
        )
        ;; ### decay ###
        (if 
          (i32.or
            (f32.ge            
              (local.tee $counter
                (f32.add 
                  (f32.load (&delta;))
                  (local.get $counter)
                )
              )
              (f32.load (i32.add(&Envelope.decay_time;) (local.get $env_param_offset)))
            )
            (f32.le
              (local.get $value)
              (f32.load (i32.add(&Envelope.sustain_level;) (local.get $env_param_offset)))
            )
          )
          (then
            (i32.store
              (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
              (i32.const 2)
            )

            (f32.store
              (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
              (local.tee $counter
                (f32.const 0)
              )
            )
            (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
              (local.tee $value 
                (f32.load 
                    (i32.add (&Envelope.sustain_level;) (local.get $env_param_offset))
                )
              ) 
            )
          )
          (else
            (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
              (local.tee $value
                (f32.sub (local.get $value)
                  (f32.load (i32.add (&Envelope.decay_delta;) (local.get $env_param_offset)))
                )
              )
            )
          )
        )
        (br $main)
      )
    ;; ### release ###
    (if 
      (i32.or 
        (f32.ge            
          (local.tee $counter
            (f32.add 
              (f32.load (&delta;))
              (local.get $counter)
            )
          )
          (f32.load (i32.add(&Envelope.release_time;) (local.get $env_param_offset)))
        )
        (f32.le 
          (local.get $value)
          (f32.const 0.000001)
        )
      )
      (then
        (i32.store
          (i32.add (&EnvelopeWork.step;) (local.get $env_work_offset))
          (i32.const -1)
        )
        (f32.store
          (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
          (local.tee $counter
            (f32.const 0)
          )
        )
        (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
          (local.tee $value (f32.const 0)) 
        )
      )
      (else
        (f32.store (i32.add (&EnvelopeWork.value;) (local.get $env_work_offset))
          (local.tee $value
            (f32.sub (local.get $value)
              (f32.load (i32.add (&Envelope.release_delta;) (local.get $env_param_offset)))
            )
          )
        )
      )
    )
    (br $main)
  )
  
  ;; カウンタを更新
  (f32.store 
    (i32.add (&EnvelopeWork.counter;) (local.get $env_work_offset))
    (local.get $counter)
  )

  ;; level * eg を出力 
  (return 
    (f32.mul 
      (local.get $value)
      (f32.load (i32.add (&Envelope.level;) (local.get $env_param_offset)))
    )
  )
)


;; ==================================
;; Filter 
;; 以下サイトのC++コードを参考に実装
;; http://vstcpp.wpblog.jp/?page_id=728
;; ==================================

;; -----------------------
;; low pass filter
;; -----------------------

(func $lowPassFilter
  (param $filter_work i32)
  (local $filter i32)
  (local $omega f32)
  (local $cos_omega f32)
  (local $alpha f32)
  ;;
  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )
  ;; omega = 2.0f * 3.14159265f *  freq / samplerate;

  (local.set $cos_omega
    (f32.demote_f64 
      (call $cos 
        (f64.promote_f32 
          (local.tee $omega
            (f32.mul
              (f32.mul
                (f32.const {$ Math.PI * 2; })
                (f32.load
                  (i32.add
                    (&FilterWork.current_frequency;)
                    (local.get $filter_work)
                  )
                )
              )
              (f32.load (&delta;))
            )
          )
        )
      )
    )
  )
  ;; float alpha = sin(omega) / (2.0f * q);
  (local.set $alpha
    (f32.div
      (f32.demote_f64 
        (call $sin (f64.promote_f32 (local.get $omega)))
      )
      (f32.mul
        (f32.const 2.0)
        (f32.load
          (i32.add
            (&Filter.q;)
            (local.get $filter)
          )
        )
      )
    ) 
  )

  ;; フィルタ係数を求める。
  ;; a0 = 1.0f + alpha;
  (f32.store 
    (i32.add
      (&FilterWork.a0;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.const 1.0)
      (local.get $alpha)
    )
  )
  ;; a1 = -2.0f * cos(omega);
  (f32.store 
    (i32.add
      (&FilterWork.a1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  )
  ;; a2 = 1.0f - alpha;
  (f32.store 
    (i32.add
      (&FilterWork.a2;)
      (local.get $filter_work)
    )
    (f32.sub
      (f32.const 1.0)
      (local.get $alpha)
    )
  )
  ;; b0 = (1.0f - cos(omega)) / 2.0f;
  (f32.store 
    (i32.add
      (&FilterWork.b0;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.sub
        (f32.const 1.0)
        (local.get $cos_omega)
      )
      (f32.const 0.5)
    )
  )
  
  ;; b1 = 1.0f - cos(omega);
  (f32.store 
    (i32.add
      (&FilterWork.b1;)
      (local.get $filter_work)
  )
  (f32.sub
      (f32.const 1.0)
      (local.get $cos_omega)
    )
  )
  ;; b2 = (1.0f - cos(omega)) / 2.0f;  )
  (f32.store 
    (i32.add
      (&FilterWork.b2;)
      (local.get $filter_work)
    )
    (f32.load
      (i32.add
        (&FilterWork.b0;)
        (local.get $filter_work)
      )
    )
  )
)

;; -----------------------
;; high pass filter
;; -----------------------

(func $highPassFilter
  (param $filter_work i32)
  (local $filter i32)
  (local $omega f32)
  (local $cos_omega f32)
  (local $alpha f32)
  ;;
  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )
  ;; omega = 2.0f * 3.14159265f *  freq / samplerate;
  (local.set $cos_omega
    (f32.demote_f64 
      (call $cos 
        (f64.promote_f32 
          (local.tee $omega
            (f32.mul
              (f32.mul
                (f32.const {$ Math.PI * 2; })
                {@@ldo f32,&FilterWork.current_frequency;,$filter_work}
              )
              (f32.load (&delta;))
            )
          )
        )
      )
    )
  )
  ;; float alpha = sin(omega) / (2.0f * q);
  (local.set $alpha
    (f32.div
      (f32.demote_f64 
        (call $sin (f64.promote_f32 (local.get $omega)))
      )
      (f32.mul
        (f32.const 2.0)
        {@@ldo f32,&Filter.q;,$filter}
      )
    ) 
  )

  ;; フィルタ係数を求める。
  ;; a0 = 1.0f + alpha;
  {@@sto f32,&FilterWork.a0;,$filter_work,
    (f32.add
      (f32.const 1.0)
      (local.get $alpha)
    )
  }

  ;; a1 = -2.0f * cos(omega);
  {@@sto f32,&FilterWork.a1;,$filter_work,
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  }

  ;; a2 = 1.0f - alpha;
  (f32.store 
    (i32.add
      (&FilterWork.a2;)
      (local.get $filter_work)
    )
    (f32.sub
      (f32.const 1.0)
      (local.get $alpha)
    )
  )

  ;; b0 = (1.0f + cos(omega)) / 2.0f;
  (f32.store 
    (i32.add
      (&FilterWork.b0;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.add
        (f32.const 1.0)
        (local.get $cos_omega)
      )
      (f32.const 0.5)
    )
  )
  
  ;; b1 = -(1.0f + cos(omega));
  (f32.store 
    (i32.add
      (&FilterWork.b1;)
      (local.get $filter_work)
    )
    (f32.neg
      (f32.add
          (f32.const 1.0)
          (local.get $cos_omega)
      )
    )
  )
  
  ;; b2 = (1.0f - cos(omega)) / 2.0f;  )
  {@@sto f32,&FilterWork.b2;,$filter_work,
    {@@ldo f32,&FilterWork.b0;,$filter_work}
  }
)

;; -----------------------
;; Notch Filter
;; -----------------------

(func $notchFilter
  (param $filter_work i32)
  (local $filter i32)
  (local $omega f64)
  (local $cos_omega f32)
  (local $sin_omega f64)
  (local $alpha f32)
  ;;
  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )

  ;; float omega = 2.0f * 3.14159265f *  freq / samplerate;
  (local.set $cos_omega
    (f32.demote_f64 
      (call $cos 
        (local.tee $omega
          (f64.promote_f32 
            (f32.mul
              (f32.mul
                (f32.const {$ Math.PI * 2; })
                (f32.load
                  (i32.add
                    (&FilterWork.current_frequency;)
                    (local.get $filter_work)
                  )
                )
              )
              (f32.load (&delta;))
            )
          )
        )
      )
    )
  )

  ;; float alpha = sin(omega) * sinh(log(2.0f) / 2.0 * bw * omega / sin(omega));
  (local.set $sin_omega
    (call $sin (local.get $omega))
  )
  (local.set $alpha
    (f32.demote_f64 
      (f64.mul
        (local.get $sin_omega)
        (call $sinh
          (f64.div
            (f64.mul
              (f64.mul
                (f64.const {$ Math.log(2.0) / 2.0 ;})
                (f64.promote_f32
                  {@@ldo f32,&Filter.band_width;,$filter_work}
                )
              )
              (local.get $omega)
            )
            (local.get $sin_omega)
          )
        )
      )
    )
  )

  ;; フィルタ係数を求める。
  ;; a0 = 1.0f + alpha;    
  {@@sto f32,&FilterWork.a0;,$filter_work,
    (f32.add
      (f32.const 1.0)
      (local.get $alpha)
    )
  }

  ;;a1 = -2.0f * cos(omega);
  {@@sto f32,&FilterWork.a1;,$filter_work,
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  }

  ;; a2 = 1.0 - alpha;
  {@@sto f32,&FilterWork.a2;,$filter_work,
    (f32.sub
      (f32.const 1.0)
      (local.get $alpha)
    )
  }

  ;; b0 = 1.0f;
  {@@sto f32,&FilterWork.b0;,$filter_work,
    (f32.const 1)
  }
  
  ;; b1 = -2.0f * cos(omega);
  {@@sto f32,&FilterWork.b1;,$filter_work,
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  }

  ;; b2 = 1.0f;
  {@@sto f32,&FilterWork.b2;,$filter_work,
    (f32.const 1)
  }

)

;; -----------------------
;; Band Pass Filter
;; -----------------------

(func $bandPassFilter
  (param $filter_work i32)
  (local $filter i32)
  (local $omega f64)
  (local $cos_omega f32)
  (local $sin_omega f64)
  (local $alpha f32)
  ;;
  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )
  ;; omega = 2.0f * 3.14159265f *  freq / samplerate;

  (local.set $cos_omega
    (f32.demote_f64 
      (call $cos 
        (local.tee $omega
          (f64.promote_f32 
            (f32.mul
              (f32.mul
                (f32.const {$ Math.PI * 2; })
                (f32.load
                  (i32.add
                    (&FilterWork.current_frequency;)
                    (local.get $filter_work)
                  )
                )
              )
              (f32.load (&delta;))
            )
          )
        )
      )
    )
  )

  ;;float alpha = sin(omega) * sinh(log(2.0f) / 2.0 * bw * omega / sin(omega));
  (local.set $sin_omega
    (call $sin (local.get $omega))
  )
  (local.set $alpha
    (f32.demote_f64 
      (f64.mul
        (local.get $sin_omega)
        (call $sinh
          (f64.div
            (f64.mul
              (f64.mul
                (f64.const {$ Math.log(2.0) / 2.0 ;})
                (f64.promote_f32
                  (f32.load
                    (i32.add
                      (&Filter.band_width;)
                      (local.get $filter_work)
                    )
                  )
                )
              )
              (local.get $omega)
            )
            (local.get $sin_omega)
          )
        )

      )
    )
  )

  ;; フィルタ係数を求める。
  ;; a0 = 1.0f + alpha;
  (f32.store 
    (i32.add
      (&FilterWork.a0;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.const 1.0)
      (local.get $alpha)
    )
  )
  ;;a1 = -2.0f * cos(omega);
  (f32.store 
    (i32.add
      (&FilterWork.a1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  )
  ;; a2 = 1.0 - alpha;
  (f32.store 
    (i32.add
      (&FilterWork.a2;)
      (local.get $filter_work)
    )
    (f32.sub
      (f32.const 1.0)
      (local.get $alpha)
    )
  )

  ;;b0 = alpha;
  (f32.store 
    (i32.add
      (&FilterWork.b0;)
      (local.get $filter_work)
    )
    (local.get $alpha)
  )
  
  ;;b1 = 0.0f;
  (f32.store 
      (i32.add
        (&FilterWork.b1;)
        (local.get $filter_work)
      )
      (f32.const 0)
  )

  ;;b2 = -alpha;
  (f32.store 
    (i32.add
      (&FilterWork.b2;)
      (local.get $filter_work)
    )
    (local.get $alpha)
  )
)

;; -----------------------
;; Low Shelf Filter
;; -----------------------

(func $lowShelfFilter
  (param $filter_work i32)
  (local $filter i32)
  (local $omega f64)
  (local $cos_omega f32)
  (local $sin_omega f32)
  (local $alpha f32)
  (local $A f32)
  (local $beta f32)
  ;;
  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )

  ;; omega = 2.0f * 3.14159265f *  freq / samplerate;
  (local.set $cos_omega
    (f32.demote_f64 
      (call $cos 
        (local.tee $omega
          (f64.promote_f32 
            (f32.mul
              (f32.mul
                (f32.const {$ Math.PI * 2; })
                (f32.load
                  (i32.add
                    (&FilterWork.current_frequency;)
                    (local.get $filter_work)
                  )
                )
              )
              (f32.load (&delta;))
            )
          )
        )
      )
    )
  )

  ;; float alpha = sin(omega) / (2.0f * q);
  (local.set $sin_omega
    (f32.demote_f64
      (call $sin (local.get $omega))
    )
  )
  (local.set $alpha
    (f32.div
      (local.get $sin_omega)
      (f32.mul
        (f32.const 2)
        (f32.load
          (i32.add
            (&Filter.q;)
            (local.get $filter)
          )
        )
      )
    )
  )
  ;; float A = pow(10.0f, (gain / 40.0f));
  (local.set $A
    (f32.demote_f64
      (call $pow
        (f64.const 10.0)
        (f64.mul 
          (f64.promote_f32
            (f32.load
              (i32.add
                (&Filter.gain;)
                (local.get $filter)
              )
            )
          )
          (f64.const {$ 1 / 40.0 })
        )
      )
    )
  )

  ;; float beta = sqrt(A) / q;
  (local.set $beta
    (f32.demote_f64
      (f64.div
        (f64.sqrt
          (f64.promote_f32
            (local.get $A)
          )        
        )
        (f64.promote_f32
          (f32.load
            (i32.add
              (&Filter.q;)
              (local.get $filter)
            )
          )
        )
      )
    )
  )


  ;; フィルタ係数を求める。
  ;; a0 = (A + 1.0f) + (A - 1.0f) * cos(omega) + beta * sin(omega);
  (f32.store 
    (i32.add
      (&FilterWork.a0;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.add
        (local.get $A)
        (f32.const 1)
      )
      (f32.add
        (f32.mul
          (f32.sub
            (local.get $A)
            (f32.const 1)
          )
          (local.get $cos_omega)
        )
        (f32.mul
          (local.get $beta)
          (local.get $sin_omega)
        )
      )
    )
  )

  ;; a1 = -2.0f * ((A - 1.0f) + (A + 1.0f) * cos(omega));
  (f32.store 
    (i32.add
      (&FilterWork.a1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.const -2.0)
      (f32.add
        (f32.sub
          (local.get $A)
          (f32.const 1)
        )
        (f32.mul
          (f32.add
            (local.get $A)
            (f32.const 1)
          )
          (local.get $cos_omega)
        )
      )
    )
  )

  ;; a2 = (A + 1.0f) + (A - 1.0f) * cos(omega) - beta * sin(omega);
  (f32.store 
    (i32.add
      (&FilterWork.a2;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.add
        (local.get $A)
        (f32.const 1)
      )
      (f32.sub
        (f32.mul
          (f32.sub
            (local.get $A)
            (f32.const 1)
          )
          (local.get $cos_omega)
        )
        (f32.mul
          (local.get $beta)
          (local.get $sin_omega)
        )
      )
    )
  )

  ;; b0 = A * ((A + 1.0f) - (A - 1.0f) * cos(omega) + beta * sin(omega));
  (f32.store 
    (i32.add
      (&FilterWork.b0;)
      (local.get $filter_work)
    )
    (f32.mul
      (local.get $A)
      (f32.sub
        (f32.add
          (local.get $A)
          (f32.const 1)
        )
        (f32.add
          (f32.mul
            (f32.sub
              (local.get $A)
              (f32.const 1)
            )
            (local.get $cos_omega)
          )
          (f32.mul
            (local.get $beta)
            (local.get $sin_omega)
          )
        )
      )
    )
  )
  
  ;; b1 = 2.0f * A * ((A - 1.0f) - (A + 1.0f) * cos(omega));
  (f32.store 
    (i32.add
      (&FilterWork.b1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.mul
        (f32.const 2.0)
        (local.get $A)
      )
      (f32.sub
        (f32.sub
          (local.get $A)
          (f32.const 1)
        )
        (f32.mul
          (f32.add
            (local.get $A)
            (f32.const 1)
          )
          (local.get $cos_omega)
        )
      )
    )        
  )

  ;; b2 = A * ((A + 1.0f) - (A - 1.0f) * cos(omega) - beta * sin(omega));
  (f32.store 
    (i32.add
      (&FilterWork.b2;)
      (local.get $filter_work)
    )
    (f32.mul
      (local.get $A)
      (f32.sub
        (f32.add
          (local.get $A)
          (f32.const 1)
        )
        (f32.sub
          (f32.mul
            (f32.sub
              (local.get $A)
              (f32.const 1)
            )
            (local.get $cos_omega)
          )
          (f32.mul
            (local.get $beta)
            (local.get $sin_omega)
          )
        )
      )
    )
  )
)


;; -----------------------
;; High Shelf Filter
;; -----------------------

(func $HighShelfFilter
  (param $filter_work i32)
  (local $filter i32)
  (local $omega f64)
  (local $cos_omega f32)
  (local $sin_omega f32)
  (local $alpha f32)
  (local $A f32)
  (local $beta f32)
  ;;
  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )

  ;; omega = 2.0f * 3.14159265f *  freq / samplerate;
  (local.set $cos_omega
    (f32.demote_f64 
      (call $cos 
        (local.tee $omega
          (f64.promote_f32 
            (f32.mul
              (f32.mul
                (f32.const {$ Math.PI * 2; })
                (f32.load
                  (i32.add
                    (&FilterWork.current_frequency;)
                    (local.get $filter_work)
                  )
                )
              )
              (f32.load (&delta;))
            )
          )
        )
      )
    )
  )

  ;; float alpha = sin(omega) / (2.0f * q);
  (local.set $sin_omega
    (f32.demote_f64
      (call $sin (local.get $omega))
    )
  )
  (local.set $alpha
    (f32.div
      (local.get $sin_omega)
      (f32.mul
        (f32.const 2)
        (f32.load
          (i32.add
            (&Filter.q;)
            (local.get $filter)
          )
        )
      )
    )
  )

  ;; float A = pow(10.0f, (gain / 40.0f));
  (local.set $A
    (f32.demote_f64
      (call $pow
        (f64.const 10.0)
        (f64.mul 
          (f64.promote_f32
            (f32.load
              (i32.add
                (&Filter.gain;)
                (local.get $filter)
              )
            )
          )
          (f64.const {$ 1 / 40.0 })
        )
      )
    )
  )

  ;; float beta = sqrt(A) / q;
  (local.set $beta
    (f32.demote_f64
      (f64.div
        (f64.sqrt
          (f64.promote_f32
            (local.get $A)
          )        
        )
        (f64.promote_f32
          (f32.load
            (i32.add
              (&Filter.q;)
              (local.get $filter)
            )
          )
        )
      )
    )
  )


  ;; フィルタ係数を求める。
  ;; a0 = (A + 1.0f) - (A - 1.0f) * cos(omega) + beta * sin(omega);
  (f32.store 
    (i32.add
      (&FilterWork.a0;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.sub
        (f32.add
          (local.get $A)
          (f32.const 1)
        )
        (f32.mul
          (f32.sub
            (local.get $A)
            (f32.const 1)
          )
          (local.get $cos_omega)
        )
      )
      (f32.mul
        (local.get $beta)
        (local.get $sin_omega)
      )
    )
  )

  ;; a1 = 2.0f * ((A - 1.0f) - (A + 1.0f) * cos(omega));
  (f32.store 
    (i32.add
      (&FilterWork.a1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.const 2.0)
      (f32.sub
        (f32.sub
          (local.get $A)
          (f32.const 1)
        )
        (f32.mul
          (f32.add
            (local.get $A)
            (f32.const 1)
          )
          (local.get $cos_omega)
        )
      )
    )
  )

  ;; a2 = (A + 1.0f) - (A - 1.0f) * cos(omega) - beta * sin(omega);
  (f32.store 
    (i32.add
      (&FilterWork.a2;)
      (local.get $filter_work)
    )
    (f32.sub
      (f32.add
        (local.get $A)
        (f32.const 1)
      )
      (f32.sub
        (f32.mul
          (f32.sub
            (local.get $A)
            (f32.const 1)
          )
          (local.get $cos_omega)
        )
        (f32.mul
          (local.get $beta)
          (local.get $sin_omega)
        )
      )
    )
  )

  ;; b0 = A * ((A + 1.0f) + (A - 1.0f) * cos(omega) + beta * sin(omega));
  (f32.store 
    (i32.add
      (&FilterWork.b0;)
      (local.get $filter_work)
    )
    (f32.mul
      (local.get $A)
      (f32.add
        (f32.add
          (local.get $A)
          (f32.const 1)
        )
        (f32.add
          (f32.mul
            (f32.sub
              (local.get $A)
              (f32.const 1)
            )
            (local.get $cos_omega)
          )
          (f32.mul
            (local.get $beta)
            (local.get $sin_omega)
          )
        )
      )
    )
  )
  
  ;; b1 = -2.0f * A * ((A - 1.0f) + (A + 1.0f) * cos(omega));
  (f32.store 
    (i32.add
      (&FilterWork.b1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.mul
        (f32.const -2.0)
        (local.get $A)
      )
      (f32.add
        (f32.sub
          (local.get $A)
          (f32.const 1)
        )
        (f32.mul
          (f32.add
            (local.get $A)
            (f32.const 1)
          )
          (local.get $cos_omega)
        )
      )
    )        
  )

  ;; b2 = A * ((A + 1.0f) + (A - 1.0f) * cos(omega) - beta * sin(omega));
  (f32.store 
    (i32.add
      (&FilterWork.b2;)
      (local.get $filter_work)
    )
    (f32.mul
      (local.get $A)
      (f32.add
        (f32.add
          (local.get $A)
          (f32.const 1)
        )
        (f32.sub
          (f32.mul
            (f32.sub
              (local.get $A)
              (f32.const 1)
            )
            (local.get $cos_omega)
          )
          (f32.mul
            (local.get $beta)
            (local.get $sin_omega)
          )
        )
      )
    )
  )
) 

;; -----------------------
;; Peaking Filter
;; -----------------------

(func $PeakingFilter
  (param $filter_work i32)
  (local $filter i32)
  (local $omega f64)
  (local $cos_omega f32)
  (local $sin_omega f32)
  (local $sin_omega_f64 f64)
  (local $alpha f32)
  (local $A f32)


  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )

  ;; omega = 2.0f * 3.14159265f *  freq / samplerate;
  (local.set $cos_omega
    (f32.demote_f64 
      (call $cos 
        (local.tee $omega
          (f64.promote_f32 
            (f32.mul
              (f32.mul
                (f32.const {$ Math.PI * 2; })
                (f32.load
                  (i32.add
                    (&FilterWork.current_frequency;)
                    (local.get $filter_work)
                  )
                )
              )
              (f32.load (&delta;))
            )
          )
        )
      )
    )
  )

  ;; float alpha = sin(omega) * sinh(log(2.0f) / 2.0 * bw * omega / sin(omega));
  (local.set $sin_omega
    (f32.demote_f64
      (local.tee $sin_omega_f64
        (call $sin (local.get $omega))
      )
    )
  )

  (local.set $alpha
    (f32.demote_f64
      (f64.mul
        (local.get $sin_omega_f64)
        (call $sinh 
          (f64.div
            (f64.mul 
              (f64.mul 
                (f64.const {$ Math.log(2.0) / 2.0; })
                (f64.promote_f32
                  (f32.load 
                    (i32.add (&Filter.band_width;) (local.get $filter))
                  )
                )
              )
              (local.get $omega)
            )
            (local.get $sin_omega_f64)
          )
        )
      )
    )
  )

  ;; float A = pow(10.0f, (gain / 40.0f));
  (local.set $A
    (f32.demote_f64
      (call $pow
        (f64.const 10.0)
        (f64.mul 
          (f64.promote_f32
            (f32.load
              (i32.add
                (&Filter.gain;)
                (local.get $filter)
              )
            )
          )
          (f64.const {$ 1 / 40.0 })
        )
      )
    )
  )

  ;; フィルタ係数を求める。
  ;; a0 = 1.0f + alpha / A;
  (f32.store 
    (i32.add
      (&FilterWork.a0;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.const 1)
      (f32.div
        (local.get $alpha)
        (local.get $A)
      )
    )
  )

  ;; a1 = -2.0f * cos(omega);
  (f32.store 
    (i32.add
      (&FilterWork.a1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  )

  ;; a2 = 1.0f - alpha / A;
  (f32.store 
    (i32.add
      (&FilterWork.a2;)
      (local.get $filter_work)
    )
    (f32.sub
      (f32.const 1)
      (f32.div
        (local.get $alpha)
        (local.get $A)
      )
    )
  )

  ;; b0 = 1.0f + alpha * A;
  (f32.store 
    (i32.add
      (&FilterWork.b0;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.const 1.0)
      (f32.mul
        (local.get $alpha)
        (local.get $A)
      )
    )
  )
  
  ;; b1 = -2.0f * cos(omega);
  (f32.store 
    (i32.add
      (&FilterWork.b1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  )

  ;; b2 = 1.0f - alpha * A;
  (f32.store 
    (i32.add
      (&FilterWork.b2;)
      (local.get $filter_work)
    )
    (f32.sub
      (f32.const 1)
      (f32.mul
        (local.get $alpha)
        (local.get $A)
      )
    )
  )
) 

;; -----------------------
;; AllPass Filter
;; -----------------------

(func $allPassFilter
  (param $filter_work i32)
  (local $filter i32)
  (local $omega f64)
  (local $cos_omega f32)
  (local $sin_omega f32)
  (local $sin_omega_f64 f64)
  (local $alpha f32)
  (local $A f32)


  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )

  ;; omega = 2.0f * 3.14159265f *  freq / samplerate;
  (local.set $cos_omega
    (f32.demote_f64 
      (call $cos 
        (local.tee $omega
          (f64.promote_f32 
            (f32.mul
              (f32.mul
                (f32.const {$ Math.PI * 2; })
                (f32.load
                  (i32.add
                    (&FilterWork.current_frequency;)
                    (local.get $filter_work)
                  )
                )
              )
              (f32.load (&delta;))
            )
          )
        )
      )
    )
  )

  ;; float alpha = sin(omega) / (2.0f * q);
  (local.set $alpha
    (f32.demote_f64
      (f64.div
        (call $sin (local.get $omega))
        (f64.mul
          (f64.const 2.0)
          (f64.load
            (i32.add
              (&Filter.q;)
              (local.get $filter)
            )
          )
        )
      )
    )
  )

  ;; フィルタ係数を求める。
  ;; a0 = 1.0f + alpha;
  (f32.store 
    (i32.add
      (&FilterWork.a0;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.const 1)
      (local.get $alpha)
    )
  )

  ;; a1 = -2.0f * cos(omega);
  (f32.store 
    (i32.add
      (&FilterWork.a1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  )

  ;; a2 = 1.0f - alpha;
  (f32.store 
    (i32.add
      (&FilterWork.a2;)
      (local.get $filter_work)
    )
    (f32.sub
      (f32.const 1)
      (local.get $alpha)
    )
  )

  ;; b0 = 1.0f - alpha;
  (f32.store 
    (i32.add
      (&FilterWork.b0;)
      (local.get $filter_work)
    )
    (f32.sub
      (f32.const 1.0)
      (local.get $alpha)
    )
  )
  
  ;; b1 = -2.0f * cos(omega);
  (f32.store 
    (i32.add
      (&FilterWork.b1;)
      (local.get $filter_work)
    )
    (f32.mul
      (f32.const -2.0)
      (local.get $cos_omega)
    )
  )

  ;; b2 = 1.0f + alpha;
  (f32.store 
    (i32.add
      (&FilterWork.b2;)
      (local.get $filter_work)
    )
    (f32.add
      (f32.const 1)
      (local.get $alpha)
    ) 
  )
) 

;; -----------------------
;; filterの実行
;; -----------------------

(func $processFilter 
  (param $filter_work i32)
  (param $in f32)
  (result f32)
  (local $filter i32)

  (local $a0 f32)
  (local $a1 f32)
  (local $a2 f32)
  (local $b0 f32)
  (local $b1 f32)
  (local $b2 f32)
  (local $out f32)
  (local $out1 f32)
  (local $out2 f32)
  (local $in1 f32)
  (local $in2 f32)

  (local.set $filter
    (i32.load
      (local.get $filter_work)
    )
  )

  (local.set $a0
    (f32.load
      (i32.add 
        (&FilterWork.a0;)
        (local.get $filter_work)
      )
    )
  )
  (local.set $a1
    (f32.load
      (i32.add 
        (&FilterWork.a1;)
        (local.get $filter_work)
      )
    )
  )
  (local.set $a2
    (f32.load
      (i32.add 
        (&FilterWork.a2;)
        (local.get $filter_work)
      )
    )
  )
  (local.set $b0
    (f32.load
      (i32.add 
        (&FilterWork.b0;)
        (local.get $filter_work)
      )
    )
  )
  (local.set $b1
    (f32.load
      (i32.add 
        (&FilterWork.b1;)
        (local.get $filter_work)
      )
    )
  )
  (local.set $b2
    (f32.load
      (i32.add 
        (&FilterWork.b2;)
        (local.get $filter_work)
      )
    )
  )

  (local.set $out1
    (f32.load
      (i32.add 
        (&FilterWork.out1;)
        (local.get $filter_work)
      )
    )
  )
  (local.set $out2
    (f32.load
      (i32.add 
        (&FilterWork.out2;)
        (local.get $filter_work)
      )
    )
  )
  (local.set $in1
    (f32.load
      (i32.add 
        (&FilterWork.in1;)
        (local.get $filter_work)
      )
    )
  )

  (local.set $in2
    (f32.load
      (i32.add 
        (&FilterWork.in2;)
        (local.get $filter_work)
      )
    )
  )
  ;; // 入力信号にフィルタを適用し、出力信号変数に保存。
  ;; float out = b0 / a0 * in + b1 / a0 * in1 + b2 / a0 * in2
  ;; 	- a1 / a0 * out1 - a2 / a0 * out2;
  (local.set $out
    (f32.sub
      (f32.sub
        (f32.add
          (f32.mul 
            (f32.div
              (local.get $b0)
              (local.get $a0)
            )
            (local.get $in)
          )
          (f32.add
            (f32.mul
              (f32.div
                (local.get $b1)
                (local.get $a0)
              )
              (local.get $in1)
            )
            (f32.mul
              (f32.div
                (local.get $b2)
                (local.get $a0)
              )
              (local.get $in2)
            )
          )
        )
        (f32.mul
          (f32.div
            (local.get $a1)
            (local.get $a0)
          )
          (local.get $out1)
        )      
      )
      (f32.mul
        (f32.div
          (local.get $a2)
          (local.get $a0)
        )
        (local.get $out2)
      )
    )
  )
  ;; out2 = out1; // 2つ前の出力信号を更新
  (f32.store
    (i32.add
      (&FilterWork.out2;)
      (local.get $filter_work)
    )
    (local.get $out1)
  )

  ;; out1 = out;  // 1つ前の出力信号を更新
  (f32.store
    (i32.add
      (&FilterWork.out1;)
      (local.get $filter_work)
    )
    (local.get $out)
  )

  ;; in2 = in1; // 2つ前の入力信号を更新
  (f32.store
    (i32.add
      (&FilterWork.in2;)
      (local.get $filter_work)
    )
    (local.get $in1)
  )
  ;; in1 = in;  // 1つ前の入力信号を更新
  (f32.store
    (i32.add
      (&FilterWork.in1;)
      (local.get $filter_work)
    )
    (local.get $in)
  )
  ;; // 出力信号を返す
  (local.get $out)
)

(func $initFilter
  (param $filter i32)
  (param $filter_type i32)
  (param $base_frequency f32)
  (param $q f32)
  (param $band_width f32)
  (param $gain f32)

  (i32.store
    (i32.add
      (&Filter.filter_type;)
      (local.get $filter)
    )
    (local.get $filter_type)
  )

  (f32.store
    (i32.add
      (&Filter.base_frequency;)
      (local.get $filter)
    )
    (local.get $base_frequency)
  )

  (f32.store
    (i32.add
      (&Filter.q;)
      (local.get $filter)
    )
    (local.get $q)
  )

  (f32.store
    (i32.add
      (&Filter.band_width;)
      (local.get $filter)
    )
    (local.get $band_width)
  )

  (f32.store
    (i32.add
      (&Filter.gain;)
      (local.get $filter)
    )
    (local.get $gain)
  ) 
)

(func $initFilterWork
  (param $filter i32)
  (param $filter_work i32)

  (i32.store
    (local.get $filter_work)
    (local.get $filter)
  )

  (f32.store
    (i32.add
      (&FilterWork.a0;)
      (local.get $filter_work)
    )
    (f32.const 1)
  )

  (f32.store
    (i32.add
      (&FilterWork.a1;)
      (local.get $filter_work)
    )
    (f32.const 0)
  )

  (f32.store
    (i32.add
      (&FilterWork.a2;)
      (local.get $filter_work)
    )
    (f32.const 0)
  )
  
  (f32.store
    (i32.add
      (&FilterWork.b0;)
      (local.get $filter_work)
    )
    (f32.const 1)
  )

  (f32.store
    (i32.add
      (&FilterWork.b1;)
      (local.get $filter_work)
    )
    (f32.const 0)
  )

  (f32.store
    (i32.add
      (&FilterWork.b2;)
      (local.get $filter_work)
    )
    (f32.const 0)
  )

  (f32.store
    (i32.add
      (&FilterWork.freq_rate;)
      (local.get $filter_work)
    )
    (f32.const 1)
  )

  (f32.store
    (i32.add
      (&FilterWork.current_frequency;)
      (local.get $filter_work)
    )
    (f32.load
      (i32.add
        (&Filter.base_frequency;)
        (local.get $filter)
      )
    )
  )

  (f32.store
    (i32.add
      (&FilterWork.in1;)
      (local.get $filter_work)
    )
    (f32.const 0)
  )

  (f32.store
    (i32.add
      (&FilterWork.in2;)
      (local.get $filter_work)
    )
    (f32.const 0)
  )

  (f32.store
    (i32.add
      (&FilterWork.out1;)
      (local.get $filter_work)
    )
    (f32.const 0)
  )

  (f32.store
    (i32.add
      (&FilterWork.out2;)
      (local.get $filter_work)
    )
    (f32.const 0)
  )
)

;; --------------------------
;; 音色
;; --------------------------


(func $keyOnTimbre
  (param $timbre_work i32)
  ;; key on フラグのセット
  (i32.store
    (i32.add
      (&TimbreWork.flag;)
      (local.get $timbre_work)
    )
    (i32.or
      (i32.load
        (i32.add
          (&TimbreWork.flag;)
          (local.get $timbre_work)
        )
      )
      (i32.const 0x1)
    )
  )

  ;; envelopeのキーオン処理
  ;; pitch
  (call $keyOnEnvelope
    (i32.add
      (&TimbreWork.pitch_envelope;)
      (local.get $timbre_work)
    )
  )
  ;; amplitude
  (call $keyOnEnvelope
    (i32.add
      (&TimbreWork.amplitude_envelope;)
      (local.get $timbre_work)
    )
  )
  ;; filter
  (call $keyOnEnvelope
    (i32.add
      (&TimbreWork.filter_envelope;)
      (local.get $timbre_work)
    )
  )
)

(func $keyOffTimbre
  (param $timbre_work i32)
  ;; key off  フラグのリセット
  (i32.store
    (i32.add
      (&TimbreWork.flag;)
      (local.get $timbre_work)
    )
    (i32.and
      (i32.load
        (i32.add
          (&TimbreWork.flag;)
          (local.get $timbre_work)
        )
      )
      (i32.const 0xffff_fffe)
    )
  )

  ;; envelopeのキーoff処理
  ;; pitch
  (call $keyOffEnvelope
    (i32.add
      (&TimbreWork.pitch_envelope;)
      (local.get $timbre_work)
    )
  )
  ;; amplitude
  (call $keyOffEnvelope
    (i32.add
      (&TimbreWork.amplitude_envelope;)
      (local.get $timbre_work)
    )
  )

  ;; filter
  (call $keyOffEnvelope
    (i32.add
      (&TimbreWork.filter_envelope;)
      (local.get $timbre_work)
    )
  )

)

(func $processTimbre
  (param $timbre_work i32)
  (result f32)
  (local $oscillator_work_offset i32)
  (local $pitch_lfo_work_offset i32)
  (local $amplitude_lfo_work_offset i32)
  (local $filter_lfo_work_offset i32)
  (local $pitch f32)
  (local $oscillator_offset i32)
  (local $timbre_flag i32)
  (local $filter_value f32)
  (local $filter i32)
  (local $temp f32)

  (local.set $timbre_flag
    (i32.load
      (i32.add
        (&Timbre.flag;)
        {@@ldo i32,&TimbreWork.timbre_offset;,$timbre_work}
      )
    )
  )

  (local.set $oscillator_offset
    (i32.load
      (i32.add
        (&OscillatorWork.param_offset;)
        (i32.add
          (&TimbreWork.oscillator_work_offset;)
          (local.get $timbre_work)
        )
      )
    )
  )
  
  ;; Pitchの処理
  ;; pitch = pitch * lfo * envelope
  (f32.store
    (i32.add
      (&OscillatorWork.pitch;)
      (local.tee $oscillator_work_offset
        {@@offset &TimbreWork.oscillator_work_offset;,$timbre_work}
      )
    )
    (f32.mul
      {@@clamp 
        (f32.add
          ;; pitch
          (local.tee $pitch
            (f32.load
              (i32.add
                (&TimbreWork.pitch;)
                (local.get $timbre_work)
              )
            )
          )
          ;; lfo処理
          (if (result f32)
            (i32.and
              (local.get $timbre_flag)
              (i32.const 0x2)
            )
            (then
              (call_indirect (type $oscillatorFunc) 
                (local.tee $pitch_lfo_work_offset
                  (i32.add
                    (&TimbreWork.pitch_lfo_work_offset;)
                    (local.get $timbre_work)
                  )
                )
                (i32.load
                  (i32.add
                    (&Oscillator.call_index;)
                    (i32.load
                      (i32.add
                        (&OscillatorWork.param_offset;)
                        (local.get $pitch_lfo_work_offset)
                      )            
                    )
                  )
                )
              )
            )
            (else
              (f32.const 0.0) 
            )
          )
        ),$temp,0.0,1.0
      }
      ;; envelope
      (if (result f32)
        (i32.and
          (local.get $timbre_flag)
          (i32.const 0x1)
        )
        (then
          (call $doEnvelope
            (i32.add
              (&TimbreWork.pitch_envelope;)
              (local.get $timbre_work)
            )
          )
        )
        (else
          (f32.const 1)
        )
      )
    )
  )

  ;; フィルタ処理
  (if 
    (i32.and
      (local.get $timbre_flag)
      (i32.const 16)
    )
    
    (then
      (local.set $filter_value
        (f32.mul
          ;; filter envelope
          (if (result f32) 
            (i32.and (local.get $timbre_flag) (i32.const 32))
            (then
              (call $doEnvelope
                (i32.add
                  (&TimbreWork.filter_envelope;)
                  (local.get $timbre_work)
                )
              )
            )
            (else 
              (f32.const 1)
            )
          )
          ;; filter lfo
          (if (result f32)
            (i32.and (local.get $timbre_flag) (i32.const 64))
            (then
              {@@adjust_positive
                (call_indirect (type $oscillatorFunc) 
                  (local.tee $filter_lfo_work_offset
                    {@@offset &TimbreWork.filter_lfo_work_offset;,$timbre_work}
                  )
                  (i32.load
                    (i32.add
                      (&Oscillator.call_index;)
                      {@@ldo i32,&OscillatorWork.param_offset;,$filter_lfo_work_offset}
                    )
                  )
                )
              }
            )
            (else 
              (f32.const 1)
            )
          )
        )
      )
      ;; フィルタの更新
      (local.set $filter
        {@@ldo i32,&TimbreWork.filter;,$timbre_work}
      )

      ;; フィルタ値を更新
      {@@sto f32,&TimbreWork.filter.freq_rate;,$timbre_work,
        (local.get $filter_value)
      }

      {@@sto f32,&TimbreWork.filter.current_frequency;,$timbre_work,
        (f32.mul
          {@@ldo f32,&Filter.base_frequency;,$filter}
          (local.get $filter_value)
        )
      }

      (call_indirect (type $filterFunc)
        {@@offset &TimbreWork.filter;,$timbre_work}
        (i32.add
          (i32.load
            (i32.add
              (&Filter.filter_type;)
              (i32.load
                (i32.add
                  (&TimbreWork.filter;)
                  (local.get $timbre_work)
                )
              )
            )
          )
          (i32.const {$.FILTER_FUNC_INDEX})
        )
      )
    )
  )

  ;; オシレータ&音量処理
  ;; out = oscillator_output * lfo * envelope * output_level
  (f32.store 
    (i32.add
      (&TimbreWork.value;)
      (local.get $timbre_work)
    )
    (f32.mul 
      (f32.mul
        ;; フィルタ
        (if (result f32)
          (i32.and
            (local.get $timbre_flag)
            (i32.const 16)
          )
          (then
            (call $processFilter
              (i32.add 
                (&TimbreWork.filter;)
                (local.get $timbre_work)
              )
              ;; オシレータ
              (call_indirect (type $oscillatorFunc)
                (local.get $oscillator_work_offset)
                (i32.load
                  (i32.add
                    (&Oscillator.call_index;)
                    (local.get $oscillator_offset)
                  )
                )
              )
            )
          )
          (else 
            ;; オシレータ
            (call_indirect (type $oscillatorFunc)
              (local.get $oscillator_work_offset)
              (i32.load
                (i32.add
                  (&Oscillator.call_index;)
                  (local.get $oscillator_offset)
                )
              )
            )
          )
        )
        ;; amplitude envelope
        (if (result f32)
          (i32.and
            (local.get $timbre_flag)
            (i32.const 0x4)
          )
          (then
            (call $doEnvelope
              (i32.add
                (&TimbreWork.amplitude_envelope;)
                (local.get $timbre_work)
              )
            )
          )
          (else
            (f32.const 1)
          )
        )
      )
      ;; output level
      {@@clamp 
        (f32.add 
          ;; amplitude lfo
          (if (result f32)
            (i32.and
              (local.get $timbre_flag)
              (i32.const 0x8)
            )
            (then
              (call_indirect (type $oscillatorFunc) 
                (local.tee $amplitude_lfo_work_offset
                  (i32.add
                    (&TimbreWork.amplitude_lfo_work_offset;)
                    (local.get $timbre_work)
                  )
                )
                (i32.load
                  (i32.add
                    (&Oscillator.call_index;)
                    {@@ldo i32,&OscillatorWork.param_offset;,$amplitude_lfo_work_offset}
                  )
                )
              )
            )
            (else 
              (f32.const 0.0)
            )
          )
          {@@ldo f32,&TimbreWork.output_level;,$timbre_work}
        ),
        $temp,0.0,1.0
      }
    )
  )
  ;; output 
  {@@ldo f32,&TimbreWork.value;,$timbre_work}
)


;; --------------------------------
;; test用 Timbreのセットアップ
;; --------------------------------

(func $initTestTimbre
  (result i32)
  (local $loop_counter i32)
  (local $offset_src i32)
  (local $offset_dest i32)
  (local $offset_dest1 i32)
  (local $oscillator_offset i32)
  (local $oscillator1_offset i32)
  (local $timbre_offset i32)
  
  ;; オシレータ0のセットアップ
  ;; 512サンプル分取る
  (i32.store
    (&oscillator[0];)
    (local.tee $oscillator_offset
      (call $allocateWaveTable
        (i32.const 512)
      )
    )
  )
  ;; オシレータ1のセットアップ
  ;; 32サンプル分取る
  (i32.store
    (&oscillator[1];)
    (local.tee $oscillator1_offset
      (call $allocateWaveTable
        (i32.const 32)
      )
    )
  )

  ;; sizeを32サンプルにセット
  {@@setWaveTableSize_ 
    $oscillator_offset,
    (i32.const 32)
  }
  
  {@@setWaveTableSize_
    $oscillator1_offset,
    (i32.const 32)
  }

  ;; sinデータのコピー
  (block $sin_data_copy
    (local.set $loop_counter (i32.const 32))
    (local.set $offset_src (&sin_table;)) 
    (local.set $offset_dest 
      (i32.add
        (&WaveTable.wave_data_start;)
        (i32.load (&oscillator[0];) )
      )
    )
    (local.set $offset_dest1 
      (i32.add
        (&WaveTable.wave_data_start;)
        (i32.load (&oscillator[1];) )
      )
    )

    (loop $sin_loop
      (br_if $sin_data_copy
        (i32.eqz
          (local.tee $loop_counter
            (i32.sub
              (local.get $loop_counter)
              (i32.const 1)
            )
          )
        )
      )

      (f32.store
        (local.get $offset_dest)
        (f32.load (local.get $offset_src))
      )

      (f32.store
        (local.get $offset_dest1)
        (f32.load (local.get $offset_src))
      )

      (local.set $offset_dest
        (i32.add
          (local.get $offset_dest)
          (i32.const 4)
        )
      )

      (local.set $offset_dest1
        (i32.add
          (local.get $offset_dest1)
          (i32.const 4)
        )
      )

      (local.set $offset_src
        (i32.add
          (local.get $offset_src)
          (i32.const 4)
        )
      )
      (br $sin_loop)
    )
  )

  ;; timbre 0 のセットアップ

  ;; フラグ
  (i32.store
    (&timbre[0].flag;)
    (i32.const 0x0)
  )

  ;; オシレータ
  (i32.store 
    (&timbre[0].oscillator_offset;)
    (local.get $oscillator_offset)
  )

  (f32.store
    (&timbre[0].oscillator_base_frequency;)
    (f32.const 440) ;; 440Hz
  )


  ;; ピッチ・エンベロープ
  (call $initEnvelope
    (&timbre[0].pitch_envelope;)
    (f32.load (&sample_rate;))
    (f32.const 0.00015) ;; a
    (f32.const 0.15) ;; d
    (f32.const 0.2) ;; s
    (f32.const 0.2) ;; r
    (f32.const 1.0) ;; level
  )

  ;; Pitch LFO
  (i32.store
    (&timbre[0].pitch_lfo_offset;)
    (local.get $oscillator1_offset)
  )

  (f32.store
    (&timbre[0].pitch_lfo_base_frequency;)
    (f32.const 20) ;; 20Hz
  )

  ;; 音量・エンベロープ
  
  (call $initEnvelope
    (&timbre[0].amplitude_envelope;)
    (f32.load (&sample_rate;))
    (f32.const 0.001)
    (f32.const 0.5)
    (f32.const 0.5)
    (f32.const 0.25)
    (f32.const 1.0)
  )
  
  ;; 音量LFO・オフセット
  (i32.store
    (&timbre[0].amplitude_lfo_offset;)
    (local.get $oscillator1_offset)
  )

  (f32.store
    (&timbre[0].amplitude_lfo_base_frequency;)
    (f32.const 20) ;; 20Hz
  )

  ;; フィルタ
      
  (call $initFilter
    (&timbre[0].filter;)
    (i32.const 0)
    (f32.const 4000)
    (f32.const 1.0)
    (f32.const 0.5)
    (f32.const 1.0)
  )

  (call $initFilterWork
    (&timbre[0].filter;)
    (&timbre_work[0].filter;)
  )

  (call $initEnvelope
    (&timbre[0].filter_envelope;)
    (f32.load (&sample_rate;))
    (f32.const 0.0)
    (f32.const 2.0)
    (f32.const 0.5)
    (f32.const 2.0)
    (f32.const 1.0)
  )

  ;; フィルタLFO・オフセット
  (i32.store
    (&timbre[0].filter_lfo_offset;)
    (local.get $oscillator_offset)
  )
  
  (f32.store
    (&timbre[0].filter_lfo_base_frequency;)
    (f32.const 20) ;; 20Hz
  )

  ;; Timbre ワークのセットアップ 
  
  ;; フラグ
  (i32.store
    (&timbre_work[0].flag;)
    (i32.const 0x80000000)
  )

  ;; Timbreオフセット
  (i32.store
    (&timbre_work[0].timbre_offset;)
    (&timbre[0];)
  )

  ;; pitch
  (f32.store
    (&timbre_work[0].pitch;)
    (f32.const 1)
  )

  ;; oscillator ワーク の初期化
  (call $initWaveTableWork
    (&timbre_work[0].oscillator_work_offset;)
    (local.get $oscillator_offset)
    (f32.load 
      (&timbre[0].oscillator_base_frequency;)
    )
  )

  ;; pitch lfo ワーク の初期化
  (call $initWaveTableWork
    (&timbre_work[0].pitch_lfo_work_offset;)
    (local.get $oscillator_offset)
    (f32.load 
      (&timbre[0].pitch_lfo_base_frequency;)
    )
  )

  ;; amplitude lfo ワークの初期化
  (call $initWaveTableWork
    (&timbre_work[0].amplitude_lfo_work_offset;)
    (local.get $oscillator_offset)
    (f32.load 
      (&timbre[0].amplitude_lfo_base_frequency;)
    )
  )

  ;; filter lfo ワークの初期化
  (call $initWaveTableWork
    (&timbre_work[0].filter_lfo_work_offset;)
    (local.get $oscillator_offset)
    (f32.load 
      (&timbre[0].filter_lfo_base_frequency;)
    )
  )

  ;; pitch envelope ワークの初期化
  (call $initEnvelopeWork
    (&timbre_work[0].pitch_envelope;)
    (&timbre[0].pitch_envelope;)
  )

  ;; amplitude envelope ワークの初期化
  (call $initEnvelopeWork
    (&timbre_work[0].amplitude_envelope;)
    (&timbre[0].amplitude_envelope;)
  )
  
  ;; filter envelope ワークの初期化
  (call $initEnvelopeWork
    (&timbre_work[0].filter_envelope;)
    (&timbre[0].filter_envelope;)
  )

  ;; output level
  (f32.store
    (&timbre_work[0].output_level;)
    (f32.const 1)
  )

  (&timbre_work[0];)

)

;; --------------------------------
;; ボイスアサイン・制御
;; --------------------------------

(func $assignVoice
  (result i32)
  (local $ch i32)
  (local $timbre_work i32)
  (local $min_time i64)
  (local $timbre_work_min i32)

  (local.set $timbre_work_min
    (local.tee $timbre_work
      (&timbre_work[0];)
    )
  )

  (block $loop_end 
    (loop $loop
      (br_if $loop_end
        (i32.gt_u 
          (local.get $timbre_work)
          (&timbre_work[0];)
        )
      )
      ;; 
      (if
        (i32.eqz
          (i32.and
            (i32.const 0x8000_0001)
            {@@ldo i32,&TimbreWork.flag;,$timbre_work}
          )
        )
        (then
          (return (local.get $timbre_work))
        )
        (else
          (if 
            (i64.lt_u
              {@@ldo i64,&TimbreWork.time;,$timbre_work}
              (local.get $min_time)
            )
            (then
              (local.set $min_time
                {@@ldo i64,&TimbreWork.time;,$timbre_work}
              )
              (local.set $timbre_work_min 
                (local.get $timbre_work)
              )
            )
          )
          (local.set $timbre_work
            (i32.add
              (local.get $timbre_work)
              (#TimbreWork;)
            )
          )
          (br $loop)
        )
      )
    )
  )
  ;; すべてアクティブの場合、アサインした中で最小時間のボイスをアサインする
  (local.get $timbre_work_min)
)

;; --------------------------- 
;; output buffer
;; --------------------------- 

(func $initOutputBuffer 
  (param $size i32)
  (result i32)
  (local $offset i32)
  (i32.store 
    (&output_buffer_offset;)
    (local.tee $offset
      (call $allocateMemory
        (local.get $size)
      )
    )
  )
  
  (i32.store
    (&output_buffer_size;)
    (local.get $size)
  )

  (i32.store
    (&output_buffer_mask;)
    (i32.sub
      (local.get $size)
      (i32.const 1)
    )
  )
  (call $resetBuffer)
  (local.get $offset)
)

(func $resetBuffer
  (i32.store
    (&read_offset;)
    (i32.const 0)
  )

  (i32.store
    (&write_offset;)
    (i32.const 0)
  )

)

;; process
(func $process
    (;; local変数 ;;)
  (local $woffset i32) 
  (local $roffset i32)
  (local $buffer_mask i32)
  (local $buffer_start i32)
;;    (if (i32.eq (i32.load (&read_offset;)) (i32.load (&write_offset;)))
;;      (then
;;        (return) 
;;      ) 
;;    )

    (local.set $woffset 
      (i32.load (&write_offset;))
    )
    (local.set $roffset 
      (i32.load (&read_offset;))
    )

    (local.set $buffer_mask
      (i32.load (&output_buffer_mask;))
    )

    (local.set $buffer_start
      (i32.load (&output_buffer_offset;)) 
    )

    (block $render_exit
      (loop $render_loop
        (br_if $render_exit (i32.eq (local.get $roffset) (local.get $woffset)))
        (f32.store 
          (i32.add 
            (local.get $buffer_start) 
            (local.get $woffset)
          )
          (call $processTimbre
            (&timbre_work[0];)
          )
        )
        (local.set $woffset 
          (i32.and
            (i32.add (local.get $woffset) (i32.const 4))
            (local.get $buffer_mask)
          )
        )
        (br $render_loop)
      )
    )

    (i32.atomic.store (&write_offset;) (local.get $woffset))

  )
  ;; fill
  (func $fill 
    (local $end i32) 
    (local $woffset i32) 
    (local $output f32)

    (local.set $woffset (i32.load (&output_buffer_offset;)))

    (local.set $end
      (i32.add (local.get $woffset) (i32.load (&output_buffer_size;)))
    )
 
    (block $fill_exit
      (loop $fill_loop
        (br_if $fill_exit (i32.gt_s (local.get $woffset) (local.get $end)))

        (f32.store (local.get $woffset)
          (call $processTimbre
            (&timbre_work[0];)
          )
        )
        (local.set $woffset (i32.add (local.get $woffset) (i32.const 4)))
        (br $fill_loop)
      )
    )
  )





;; --------------------------- 
;; シーケンサ
;; ---------------------------

(func $allocateTrack
  (param $track_size i32)
)

(func $initTrack
  (param $track i32)
)

(func $initTrackWork
  (param $track i32)
  (param $track_work i32)
)

(func $processTrack
  (param $track_work i32)
)

(func $initSequence
  (param $sequence)
)

(func $initSequenceWork
  (param $sequence)
  (param $sequence_work)
)

(func $processSequence
  (param $sequence_work)
  (local $current_step i32)
  (local $step_counter i32)
  (local $track_work i32)
  (local $track_loop_end i32)
  (local $track_data_offset i32)
  (if 
    (i32.le_s
      (local.tee $step_counter
        {@@ldo i32,&SequenceWork.step_counter;,$sequence_work}  
      )
    )
    (then
      ;; カウンタをリセットする
      {@@sto i32,&SequenceWork.step_counter;,$sequence_work,
        (i32.add 
          (local.get $step_counter)
          (i32.trunc_f32_s
            (f32.load (&sample_rate;))
          )
        )
      }
      ;; ステップを進める
      {@@sto i32,&SequenceWork.current_step;,$sequence_work,
        (i32.add
          (local.tee $current_step
            {@@ldo i32,&SequenceWork.current_step;,&sequence_work}
          )
          (i32.const 1)
        )
      }
      ;; トラックごとの処理
      (local.set $track_work
        {@@offset &SequenceWork.track.track[0];,$sequence_work}
      )

      (local.set $track_loop_end
        {@@offset &SequenceWork.track.track[8];,$sequence_work}
      )
      (block $track_loop_exit
        (loop $track_loop
          (br_if $track_loop_exit
            (i32.gt 
              (local.get $track_work)
              (local.get $track_loop_end)
            )
          )
          ;; シーケンス処理
          (if 
            (i32.le_u
              (i32.and
                (local.tee $step_command
                  (i32.load
                    (local.tee $track_data_offset
                      {@@ldo i32,&TrackWork.current_offset;,$track_work}
                    )
                  )
                )
                (i32.const 0x1ffff)
              )
              (local.get $current_step)
            )
            (then
              (local.set $command
                (i32.and
                  (local.get $step_command)
                  (i32.const 
                )
              )
            )
          )

          (local.set $track_work
            (i32.add
              (local.get $track_work)
              (#TrackWork;)
            )
          )
          (br $track_loop)
        )
      )
    )
    (else
      ;; 
      {@@sto i32,&SequenceWork.step_counter;,$sequence_work,
        (i32.sub 
          (local.get $step_counter)
          {@@ldo i32,&SequenceWork.delta;,$sequence_work}
        )
      }
    )
  )
)

)

